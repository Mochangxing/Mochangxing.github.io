<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.1.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.1.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Mochangxing">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mochangxing">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mochangxing">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Mochangxing</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mochangxing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/17/ReactCocoa-内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/17/ReactCocoa-内存管理/" itemprop="url">
                  ReactiveCoCoa 内存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-17T22:47:06+08:00">2018-04-17</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>ReactiveCoCoa的内存管理相当的复杂，不过最终的结果是<strong>你可以不通过持有信号来处理他们</strong></p>
<p>如果ReactiveCoCoa框架要求你持有每一个信号，它使用起来将会很笨重，对于像网络请求等这些在未来使用的一次性信号来说，更是如此。你必须将长期存在的信号保存在属性中，当你完成相关操作后，还要确保将其清除，这很没意思。</p>
<h3 id="订阅者（Subscribers）"><a href="#订阅者（Subscribers）" class="headerlink" title="订阅者（Subscribers）"></a>订阅者（Subscribers）</h3><p>在进一步讨论之前，需要注意的是：<code>subscribeNext:error:completed:</code>（及其变体）会在<code>block</code>内隐式创建订阅者。因此在block中持有的任何对象，都会被订阅者持有。就像其他任何对象一样，self如果没有直接或间接引用它，它们 将不会被保留。</p>
<h3 id="有限或者短期的信号（Finite-Or-Short-Lived-Signals）"><a href="#有限或者短期的信号（Finite-Or-Short-Lived-Signals）" class="headerlink" title="有限或者短期的信号（Finite Or Short-Lived Signals）"></a>有限或者短期的信号（Finite Or Short-Lived Signals）</h3><p>RAC内存管理最重要的指导原则是，订阅关系会在完成或者发生错误后终结，并且订阅者会被移除。</p>
<p>举个栗子，假如你有如下代码在view controller里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.disposable = [signal subscribeCompleted:^&#123;</span><br><span class="line">    doSomethingPossiblyInvolving(self);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>内存管理就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view controller -&gt; RACDisposable -&gt; RACSignal -&gt; RACSubscriber -&gt; view controller</span><br></pre></td></tr></table></figure>
<p>然而，一旦signal结束这种<code>RACSignal -&gt; RACSubscriber</code>关系就会被拆除 ，从而打破了引用环。<br>通常，这正是你所需要的，因为RACSignal的生命周期自然会匹配事件流的逻辑生命周期。</p>
<h3 id="无限信号-Infinite-Signals"><a href="#无限信号-Infinite-Signals" class="headerlink" title="无限信号(Infinite Signals)"></a>无限信号(Infinite Signals)</h3><p>无线信号（或者存活时间太久以致它们可能是无限的信号），并不会自动释放。这时候<code>disposables</code>就派上用场了<br><strong>处理（也就是调用<code>disposable</code>的<code>dispose</code>方法）订阅关系将会移除关联的订阅者，</strong>，并将优雅地清理相关的资源。对于订阅者而言，就好像信号已经完成或者发生了错误。其他的订阅者并不受影响。<br>如果您必须手动管理订阅的生命周期，<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/Documentation/DesignGuidelines.md#avoid-explicit-subscriptions-and-disposal" target="_blank" rel="noopener">那么可能有更好的方法来执行您想要的操作</a>。</p>
<h3 id="来自于self的信号（Signals-Derived-from-self）"><a href="#来自于self的信号（Signals-Derived-from-self）" class="headerlink" title="来自于self的信号（Signals Derived from self）"></a>来自于<code>self</code>的信号（Signals Derived from self）</h3><p>虽然，这里仍然存在一些棘手的中间情况。任何时候信号的生命周期都与调用范围联系在一起，你将有一个更难打破的引用环。<br>这通常发生在使用<code>RACObserve()</code>关联<code>self</code>的key path，并需要使用<code>block</code>捕获<code>self</code>的时候。<br>最简单的办法是使用__weak</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__weak id weakSelf = self;</span><br><span class="line">[RACObserve(self, username) subscribeNext:^(NSString *username) &#123;</span><br><span class="line">    id strongSelf = weakSelf;</span><br><span class="line">    [strongSelf validateUsername];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>或者，在引入 <a href="https://github.com/jspahrsummers/libextobjc/blob/master/extobjc/EXTScope.h" target="_blank" rel="noopener">EXTScope.h</a> 头文件后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">[RACObserve(self, username) subscribeNext:^(NSString *username) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    [self validateUsername];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>（如果对象不支持弱引用，分别使用，<strong>unsafe_unretained或者@unsafeify替换</strong>weak或@weakify）</p>
<p>不过，<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/Documentation/DesignGuidelines.md#avoid-explicit-subscriptions-and-disposal" target="_blank" rel="noopener">你可以使用更好的模式</a>。例如，上面的例子可以写成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ self  rac_liftSelector：@selector（validateUsername：）withSignals：RACObserve（self，username），nil ];</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * validated = [ RACObserve（self，username）map： ^（NSString * username）&#123;</span><br><span class="line">     //将验证逻辑放在这里。</span><br><span class="line">    return @ YES ; </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>跟无限信号一样，这可以避免在信号流的<code>block</code>中持有<code>self</code></p>
<hr>
<p>为了有效使用ReactiveCocoa，以上就是你所需要的全部信息。然而，还有一点需要解决，只是出于技术上的好奇，或者任何对RAC有贡献的人。</p>
<p>“不需要持有”的设计目标引出一个问题：我们怎么知道一个信号何时被释放？如果只是创建而没有被持有呢？<br>答案是<em>我们无法知道</em>，但是我们通常可以假设调用者会在当前运行循环迭代中保留信号，如果他们想保留它的话。<br>所以：</p>
<ol>
<li>创建的信号会自动添加到全局活动信号集。</li>
<li>该信号将等待主线程RunLoop的一次循环，然后如果它没有订户，则从活动集中移出。除非信号以某种方式保留，否则它将在此处释放</li>
<li>如果信号在RunLoop迭代中被订阅了，它将会被保留在信号集里</li>
<li>当所有订阅者都被移除了，步骤2就会被触发</li>
</ol>
<p>如果RunLoop以递归的方式运转，这将适得其反。不过大多数或全部情况下ReactiveCocoa框架会简化使用者的代码。 </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/ReactiveCocoa-基本操作符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/ReactiveCocoa-基本操作符/" itemprop="url">
                  ReactiveCocoa 基本操作符
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T14:03:12+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近打算好好学习下ReactiveCocoa，个人认为最好的学习方式就是看官方文档。这篇基本操作符的介绍，也是翻译自<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/Documentation/BasicOperators.md" target="_blank" rel="noopener">官方文档</a>。</p>
</blockquote>
<h1 id="基本操作符"><a href="#基本操作符" class="headerlink" title="基本操作符"></a>基本操作符</h1><p>本文档解释了ReactiveCocoa中最常用的操作符，并包含了演示其用法的的示例<br>适用于<strong><code>sequences</code></strong> 和 <strong><code>signal</code></strong>的操作符被称为<strong><code>stream</code></strong>的操作符</p>
<h2 id="执行信号产生的副作用"><a href="#执行信号产生的副作用" class="headerlink" title="执行信号产生的副作用"></a>执行信号产生的副作用</h2><p>大多数信号都是冷信号，这意味着直到被<strong>订阅</strong>它们才会生效。<br>订阅后，信号或者他的订阅者可以执行，例如打印到控制台、发起网络请求、更新UI等操作。</p>
<p>###订阅（Subscription）</p>
<p><code>-subscribe</code>系列方法可以访问<code>signal</code>的当前以及未来的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *letters = [@&quot;A B C D E F G H I&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence.signal;</span><br><span class="line"></span><br><span class="line">// Outputs: A B C D E F G H I</span><br><span class="line">[letters subscribeNext:^(NSString *x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>对于冷信号来说，每一次订阅都将执行一次副作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__block unsigned subscriptions = 0;</span><br><span class="line">   </span><br><span class="line">   RACSignal *loggingSignal = [RACSignal createSignal:^RACDisposable *(id &lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       subscriptions++;</span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">       return nil;</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   // Outputs:</span><br><span class="line">   // subscription 1</span><br><span class="line">   [loggingSignal subscribeCompleted:^&#123;</span><br><span class="line">       NSLog(@&quot;subscriptions %lu&quot;, subscriptions);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   // Outputs:</span><br><span class="line">   // subscription 2</span><br><span class="line">   [loggingSignal subscribeCompleted:^&#123;</span><br><span class="line">       NSLog(@&quot;subscriptions %lu&quot;, subscriptions);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<p>这种行为可以使用过<code>connection</code>来改变。</p>
<p>###注入副作用（Injecting effect）</p>
<p><code>-do</code>系列方法可以给<code>signal</code>添加副作用，而不需要<strong>订阅</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__block unsigned subscriptions = 0;</span><br><span class="line"></span><br><span class="line">    RACSignal *loggingSignal = [RACSignal createSignal:^RACDisposable *(id &lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        subscriptions++;</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // Does not output anything yet</span><br><span class="line">    [loggingSignal doCompleted:^&#123;</span><br><span class="line">        NSLog(@&quot;about to complete subscription %u&quot;, subscriptions);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // Outputs:</span><br><span class="line">    // about to complete subscription 1</span><br><span class="line">    // subscription 1</span><br><span class="line">    [loggingSignal subscribeCompleted:^&#123;</span><br><span class="line">        NSLog(@&quot;subscriptions %lu&quot;, subscriptions);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h2 id="变换Streams"><a href="#变换Streams" class="headerlink" title="变换Streams"></a>变换Streams</h2><p>变换操作符可以将单个<code>stream</code>变换成一个新的<code>stream</code></p>
<h3 id="映射（Mapping）"><a href="#映射（Mapping）" class="headerlink" title="映射（Mapping）"></a>映射（Mapping）</h3><p><code>-map:</code>方法用于将<code>stream</code>中的值转换，并基于转换后的新值创建一个新的<code>stream</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *letters = [@&quot;A, B,C,D,E,F G,H, I&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence;</span><br><span class="line">    </span><br><span class="line">// Contains: AA BB CC DD EE FF GG HH II</span><br><span class="line">[letters map:^id(NSString * value) &#123;</span><br><span class="line">   value = [value stringByAppendingString:value];</span><br><span class="line">   return value;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="过滤（Filtering）"><a href="#过滤（Filtering）" class="headerlink" title="过滤（Filtering）"></a>过滤（Filtering）</h3><p><code>-filter:</code>方法使用一个block，来筛选出符合条件的值，并生成新的<code>stream</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *numbers = [@&quot;1 2 3 4 5 6 7 8 9&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence;</span><br><span class="line">    </span><br><span class="line">// Contains: 2 4 6 8</span><br><span class="line">RACSequence *filtered = [numbers filter:^BOOL(NSNumber * value) &#123;</span><br><span class="line">   return value.intValue % 2 == 0;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="结合流（Combining-Streams）"><a href="#结合流（Combining-Streams）" class="headerlink" title="结合流（Combining Streams）"></a>结合流（Combining Streams）</h2><p>结合操作符可以将多个stream合并成单个stream</p>
<h3 id="连接（Concatenating）"><a href="#连接（Concatenating）" class="headerlink" title="连接（Concatenating）"></a>连接（Concatenating）</h3><p><code>-concat:</code>方法可以将一个<code>stream</code>拼接在另一个<code>stream</code>后面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *letters = [@&quot;A B C D E F G H I&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence;</span><br><span class="line">RACSequence *numbers = [@&quot;1 2 3 4 5 6 7 8 9&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence;</span><br><span class="line"></span><br><span class="line">// Contains: A B C D E F G H I 1 2 3 4 5 6 7 8 9</span><br><span class="line">RACSequence *concatenated = [letters concat:numbers];</span><br></pre></td></tr></table></figure>
<h3 id="扁平化（Flattening）"><a href="#扁平化（Flattening）" class="headerlink" title="扁平化（Flattening）"></a>扁平化（Flattening）</h3><p><code>-flatten</code>操作符用于包含<code>stream</code>的<code>stream</code>，将<code>stream</code>中的值也就是<code>stream</code>，组合成一个新的<code>stream</code></p>
<p>序列的连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *letters = [@&quot;A B C D E F G H I&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence;</span><br><span class="line">RACSequence *numbers = [@&quot;1 2 3 4 5 6 7 8 9&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence;</span><br><span class="line">RACSequence *sequenceOfSequences = @[letters, numbers].rac_sequence;</span><br><span class="line">   </span><br><span class="line">// Contains: A B C D E F G H I 1 2 3 4 5 6 7 8 9</span><br><span class="line">RACSequence *flattenedSequence = [sequenceOfSequences flatten];</span><br></pre></td></tr></table></figure>
<p>信号的合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *letters = [RACSubject subject];</span><br><span class="line">RACSubject *numbers = [RACSubject subject];</span><br><span class="line">RACSignal *signalOfSignals = [RACSignal createSignal:^ RACDisposable * (id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:letters];</span><br><span class="line">    [subscriber sendNext:numbers];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *flattened = [signalOfSignals flatten];</span><br><span class="line"></span><br><span class="line">// Outputs: A 1 B C 2</span><br><span class="line">[flattened subscribeNext:^(NSString *x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[letters sendNext:@&quot;A&quot;];</span><br><span class="line">[numbers sendNext:@&quot;1&quot;];</span><br><span class="line">[letters sendNext:@&quot;B&quot;];</span><br><span class="line">[letters sendNext:@&quot;C&quot;];</span><br><span class="line">[numbers sendNext:@&quot;2&quot;];</span><br></pre></td></tr></table></figure>
<h3 id="映射和扁平化（Mapping-and-Flattening）"><a href="#映射和扁平化（Mapping-and-Flattening）" class="headerlink" title="映射和扁平化（Mapping and Flattening）"></a>映射和扁平化（Mapping and Flattening）</h3><p>扁平化本身并不是很意思，但是理解其工作原理对于<code>flattenMap</code>操作符来说很重要</p>
<p><strong><code>-flattenMap:</code></strong>操作符用于将流中的每一个值转换成一个新的流，然后再将所有返会的流扁平化成单个的流。换句话说，就是先执行<code>-flatten</code>操作再执行<code>-map:</code>操作。</p>
<p><strong><code>-flattenMap:</code>操作符可以用来拓展和编辑序列
</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *numbers = [@&quot;1 2 3 4 5 6 7 8 9&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence;</span><br><span class="line"></span><br><span class="line">// Contains: 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9</span><br><span class="line">RACSequence *extended = [numbers flattenMap:^RACStream *(NSNumber * value) &#123;</span><br><span class="line">   return @[value, value].rac_sequence;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">// Contains: 1_ 3_ 5_ 7_ 9_</span><br><span class="line">RACSequence*edited = [numbers flattenMap:^RACStream *(NSString *value) &#123;</span><br><span class="line">   if(value.intValue %2 == 0)&#123;</span><br><span class="line">       return [RACSequence empty];</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       return  [RACSequence return:[value stringByAppendingString:@&quot;_&quot;]];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>也可以用来创建多个自动重组的信号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *letters = [@&quot;A B C D E F G H I&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence.signal;</span><br><span class="line"></span><br><span class="line">[[letters flattenMap:^(NSString *letter) &#123;</span><br><span class="line">   return [RACSignal return:[letter stringByAppendingString:letter]];</span><br><span class="line">&#125;] subscribeCompleted:^&#123;</span><br><span class="line">   NSLog(@&quot;All database entries saved successfully.&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="组合信号（Combining-Signal）"><a href="#组合信号（Combining-Signal）" class="headerlink" title="组合信号（Combining Signal）"></a>组合信号（Combining Signal）</h2><p>连接操作符可以将多个信号组合成单个信号</p>
<h3 id="序列化（Sequencing）"><a href="#序列化（Sequencing）" class="headerlink" title="序列化（Sequencing）"></a>序列化（Sequencing）</h3><p><code>-then:</code>操作符开始于一个原始信号，并等待其完成，然后只转发新信号的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *letters = [@&quot;A B C D E F G H I&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence.signal;</span><br><span class="line">RACSignal *sequenced = [[letters doNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,x);</span><br><span class="line">    &#125;] then:^RACSignal * &#123;</span><br><span class="line">        return [@&quot;1 2 3 4 5 6 7 8 9&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence.signal;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="合并（Merging）"><a href="#合并（Merging）" class="headerlink" title="合并（Merging）"></a>合并（Merging）</h3><p><code>+merge:</code>操作符将那些从多个信号到达的值，转发到单个信号流中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *letters = [RACSubject subject];</span><br><span class="line">RACSubject *numbers = [RACSubject subject];</span><br><span class="line">RACSignal *merged = [RACSignal merge:@[ letters, numbers ]];</span><br><span class="line"></span><br><span class="line">// Outputs: A 1 B C 2</span><br><span class="line">[merged subscribeNext:^(NSString *x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[letters sendNext:@&quot;A&quot;];</span><br><span class="line">[numbers sendNext:@&quot;1&quot;];</span><br><span class="line">[letters sendNext:@&quot;B&quot;];</span><br><span class="line">[letters sendNext:@&quot;C&quot;];</span><br><span class="line">[numbers sendNext:@&quot;2&quot;];</span><br></pre></td></tr></table></figure>
<h3 id="合并最新值（Combining-latest-values）"><a href="#合并最新值（Combining-latest-values）" class="headerlink" title="合并最新值（Combining latest values）"></a>合并最新值（Combining latest values）</h3><p><strong><code>+combineLatest:</code></strong> 和 <strong><code>+combineLatest:reduce:</code></strong>方法将观察多个信号的变化，当其中一个信号发生变化时，就将所有信号的最新值发送出去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *letters = [RACSubject subject];</span><br><span class="line">RACSubject *numbers = [RACSubject subject];</span><br><span class="line">RACSignal *combined = [RACSignal</span><br><span class="line">    combineLatest:@[ letters, numbers ]</span><br><span class="line">    reduce:^(NSString *letter, NSString *number) &#123;</span><br><span class="line">        return [letter stringByAppendingString:number];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">// Outputs: B1 B2 C2 C3</span><br><span class="line">[combined subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[letters sendNext:@&quot;A&quot;];</span><br><span class="line">[letters sendNext:@&quot;B&quot;];</span><br><span class="line">[numbers sendNext:@&quot;1&quot;];</span><br><span class="line">[numbers sendNext:@&quot;2&quot;];</span><br><span class="line">[letters sendNext:@&quot;C&quot;];</span><br><span class="line">[numbers sendNext:@&quot;3&quot;];</span><br></pre></td></tr></table></figure>
<p><strong>注意，组合信号只会在所有输入发送至少一个输入时发送其第一个值。在上面的示例中，@”A”从未转发，因为numbers尚未发送值。</strong></p>
<h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p><code>-switchToLatest</code>操作符作用于“信号的信号”，并且总是转发从最新的信号的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *letters = [RACSubject subject];</span><br><span class="line">RACSubject *numbers = [RACSubject subject];</span><br><span class="line">RACSubject *signalOfSignals = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">RACSignal *switched = [signalOfSignals switchToLatest];</span><br><span class="line"></span><br><span class="line">// Outputs: A B 1 D</span><br><span class="line">[switched subscribeNext:^(NSString *x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:letters];</span><br><span class="line">[letters sendNext:@&quot;A&quot;];</span><br><span class="line">[letters sendNext:@&quot;B&quot;];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:numbers];</span><br><span class="line">[letters sendNext:@&quot;C&quot;];</span><br><span class="line">[numbers sendNext:@&quot;1&quot;];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:letters];</span><br><span class="line">[numbers sendNext:@&quot;2&quot;];</span><br><span class="line">[letters sendNext:@&quot;D&quot;];</span><br></pre></td></tr></table></figure>
<p>以上就是ReactiveCocoa最常用的操作符的介绍</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/07/找一个靠谱的iOS面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/07/找一个靠谱的iOS面试题/" itemprop="url">
                  找一个靠谱的iOS面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-07T13:32:01+08:00">2018-04-07</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-风格纠错题-知识点官方文档"><a href="#1-风格纠错题-知识点官方文档" class="headerlink" title="1. 风格纠错题 知识点官方文档"></a>1. 风格纠错题 <a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html" target="_blank" rel="noopener">知识点官方文档</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">    UserSex_Man,</span><br><span class="line">    UserSex_Woman</span><br><span class="line">&#125; UserSex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface UserModel : NSObject</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) NSString *name;</span><br><span class="line">@property(assign, nonatomic) int age;</span><br><span class="line">@property (nonatomic, assign) UserSex sex;</span><br><span class="line"></span><br><span class="line">-(id) initUserModelWithUserName:(NSString*)name withAge:(int) age</span><br><span class="line"></span><br><span class="line">-(void) doLogin;</span><br></pre></td></tr></table></figure>
<p>考查知识点：</p>
<ul>
<li>enum NS_ENUM NS_OPTIONS</li>
<li>不可变类型数据（NSString、NSArray、NSDictionary）的修饰符的使用</li>
<li>函数命名规范</li>
<li>应避免使用基本类型，建议使用Foundation数据类型</li>
</ul>
<p>###知识点：</p>
<h4 id="enum枚举类型建议使用-NS-ENUM-或者-NS-OPTIONS-宏来定义"><a href="#enum枚举类型建议使用-NS-ENUM-或者-NS-OPTIONS-宏来定义" class="headerlink" title="enum枚举类型建议使用 NS_ENUM 或者 NS_OPTIONS 宏来定义"></a>enum枚举类型建议使用 <code>NS_ENUM</code> 或者 <code>NS_OPTIONS</code> 宏来定义</h4><p><code>NS_ENUM</code>和<code>NS_OPTIONS</code>提供了一种简明、简单的方法来定义基于C语言的枚举和选项，这些宏提高了Xcode中的代码的完成性，并明确指定了枚举和选项的类型和大小。</p>
<ul>
<li><code>NS_ENUM</code>和<code>NS_OPTIONS</code> 的区别</li>
</ul>
<p>如果需要以按位或操作来组合的枚举应该使用<code>NS_OPTIONS</code>，；如枚举不需要相互组合，则可以使用<code>NS_ENUM</code>来定义。也就是<code>NS_OPTIONS</code>适合多挣枚举类型同时存在的情况，而<code>NS_ENUM</code>适合只同时只存在一种枚举的情况</p>
<h4 id="不可变类型数据（NSString、NSArray、NSDictionary）的修饰符的使用，属性的修饰符"><a href="#不可变类型数据（NSString、NSArray、NSDictionary）的修饰符的使用，属性的修饰符" class="headerlink" title="不可变类型数据（NSString、NSArray、NSDictionary）的修饰符的使用，属性的修饰符"></a>不可变类型数据（NSString、NSArray、NSDictionary）的修饰符的使用，属性的修饰符</h4><p>不可变类型数据（NSString、NSArray、NSDictionary），都有其对应的可变类型，而且是不可变类型的子类，如果使用 strong来修饰NSString，那么NSMutableString也可以赋值给该属性，如果NSMutableString赋值给NSString后，又被修改了，那么就会出现跟预想不一致的情况了，而copy修饰NSString，在setter方法中只会将NSMutableString复制一份，而不会保留，就算NSMutableString后来改变了也没有关系</p>
<h4 id="函数命名规范"><a href="#函数命名规范" class="headerlink" title="函数命名规范"></a>函数命名规范</h4><ol>
<li>instancetype，使用instancetype关键字作为返回类的实例的方法的返回类型，而不是使用id作为返回类型，这可以提高代码的安全性</li>
<li>连接第二参数不要使用with</li>
<li>函数命名不要使用两个动词</li>
</ol>
<h4 id="应避免使用基本类型，建议使用Foundation数据类型"><a href="#应避免使用基本类型，建议使用Foundation数据类型" class="headerlink" title="应避免使用基本类型，建议使用Foundation数据类型"></a>应避免使用基本类型，建议使用Foundation数据类型</h4><p>Foundation数据在不同系统上长度是不一样的，在32位系统上int占4个字节 NSInterge也是4个字节，但是在64位系统上NSInterge占8个字节。总的来说Foundation数据兼容性会更好一下，使用Foundation数据会比使用基本类型，代码更健壮一点</p>
<p>####修改后答案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM (NSInteger, CYSex) &#123;</span><br><span class="line">    CYSexMan,</span><br><span class="line">    CYSexWoman</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface UserModel : NSObject</span><br><span class="line"></span><br><span class="line">@property(nonatomic, copy, readonly) NSString *name;</span><br><span class="line">@property(nonatomic, assign, readonly) NSUInterge age;</span><br><span class="line">@property(nonatomic, assign, readonly) CYSex sex;</span><br><span class="line"></span><br><span class="line">-(instancetype) userModelWithUserName:(NSString*)name age:(int) age</span><br><span class="line"></span><br><span class="line">-(void) login;</span><br></pre></td></tr></table></figure>
<h3 id="2-什么情况下使用weak关键字，相比assign有什么不同"><a href="#2-什么情况下使用weak关键字，相比assign有什么不同" class="headerlink" title="2. 什么情况下使用weak关键字，相比assign有什么不同"></a>2. 什么情况下使用weak关键字，相比assign有什么不同</h3><p><img src="https://raw.githubusercontent.com/Mochangxing/blogImages/master/media/15230746670632/15230825379588.jpg" alt=""></p>
<ul>
<li>weak关键字的作用：weak关键字是为了解决strong带来的循环引用的问题而生的，它不会使所引用的对象的引用计数+1，所以也就打破了引用环。weak关键字修饰的属性在其指向的对象销毁了，该属性也会被置为nil。</li>
<li>assign关键字也不会使所引用的对象引用计数+1，和weak的不同点在于，其引用的对象销毁时，assign关键字修饰的属性不会被置为nil，仍然指向了原来的地址，形成野指针。assign赋值方式：复制数据而不是复制引用</li>
</ul>
<p>结论：weak关键字适用于可能出现循环引用的地方</p>
<h3 id="3-怎么使用copy关键字？"><a href="#3-怎么使用copy关键字？" class="headerlink" title="3.怎么使用copy关键字？"></a>3.怎么使用copy关键字？</h3><ol>
<li>NSString、NSArray、NSDictionary等经常使用copy关键字，因为他们有对应的可变数据类型</li>
<li>block也经常使用copy关键字，因为在方法体内block是被分配在栈上的，使用copy之后就会分配在堆上。然后就可以在作用域外访问了</li>
</ol>
<h3 id="4-这个写法会出什么问题：-property-copy-NSMutableArray-array"><a href="#4-这个写法会出什么问题：-property-copy-NSMutableArray-array" class="headerlink" title="4. 这个写法会出什么问题： @property (copy) NSMutableArray *array;"></a>4. 这个写法会出什么问题： @property (copy) NSMutableArray *array;</h3><ol>
<li>copy修饰的话，在赋值时会变成NSArray不可变对象，那么进行增删改操作时会crash</li>
<li>property默认为 atomic，这会影响性能。</li>
</ol>
<p>一般情况下并不需要把属性声明为atomic，因为这并不能保证线程安全，只能保证读写的原子性。例如：一个线程连续多次读取属性值时，也有可能读到不同的值。</p>
<h3 id="5-如何让自己的类用copy修饰符？如何重写带copy关键字的setter？"><a href="#5-如何让自己的类用copy修饰符？如何重写带copy关键字的setter？" class="headerlink" title="5.如何让自己的类用copy修饰符？如何重写带copy关键字的setter？"></a>5.如何让自己的类用copy修饰符？如何重写带copy关键字的setter？</h3><ol>
<li>若想让自己的类的对象具备copy功能，则需要实现NSCopy协议，如果自定义的对象分为可变和不可变两个版本，那么还应该实现NSMutableCopy协议</li>
<li>重写如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(void) setName:(NSString *)name&#123;</span><br><span class="line">    _name = [name copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-property的本质是什么？ivar、getter、和setter是如何生成并添加到这个类中的"><a href="#6-property的本质是什么？ivar、getter、和setter是如何生成并添加到这个类中的" class="headerlink" title="6.@property的本质是什么？ivar、getter、和setter是如何生成并添加到这个类中的?"></a>6.@property的本质是什么？ivar、getter、和setter是如何生成并添加到这个类中的?</h3><blockquote>
<p>@property本质上等于 实例变量 + 存取方法（getter、setter）</p>
</blockquote>
<blockquote>
<p>ivar、getter、和setter是编译器通过<strong>autosynthesis（自动合成）</strong>添加到类中的</p>
</blockquote>
<h3 id="7-protocol-和category中如何使用-property？"><a href="#7-protocol-和category中如何使用-property？" class="headerlink" title="7. protocol 和category中如何使用@property？"></a>7. protocol 和category中如何使用@property？</h3><ol>
<li>protocol中使用@property，只会生成getter和setter方法声明，在protocol中使用property的目的是，希望实现该协议的类能实现该属性</li>
<li>category中使用@property也是只会生成getter和setter方法声明，如果真的需要给category增加属性需要使用一下两个函数：<code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code></li>
</ol>
<h3 id="8-Runtime如何实现weak属性"><a href="#8-Runtime如何实现weak属性" class="headerlink" title="8.Runtime如何实现weak属性"></a>8.Runtime如何实现weak属性</h3><p>Runtime其实是通过一张weak表来实现weak属性的，weak表其实是一张Hash表，key为weak指向的对象的内存地址，value则是所有weak指针的组成的数组。当weak指向的对象销毁时，Runtime就会从weak表中索引到所有指向改地址的weak指针，并全部置为nil</p>
<ul>
<li>子问题：如何让不使用weak修饰的property，拥有weak的效果？</li>
</ul>
<ol>
<li>重写setter方法，使用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN);</span><br></pre></td></tr></table></figure>
<p>这样相当于使用assign修饰了property</p>
<ol start="2">
<li>第二步需要在<code>object</code>对象销毁时，将property对应的实例变量<code>_object</code>置为nil；这一步的实现需要借助<code>category</code>以及<strong>关联对象</strong>，原理是当一个对象被销毁时，它的关联对象也会被销毁，那么只要在关联对象的的<code>dealloc</code>方法里执行block就可以达到将 实例变量<code>_object</code>置为nil的目的了</li>
</ol>
<p>setter的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(NSObject *)object</span><br><span class="line">&#123;</span><br><span class="line">  objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">  [object cyl_runAtDealloc:^&#123;</span><br><span class="line">      _object = nil;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>category的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(void) cyl_runAtDealloc:(voidBlock) block&#123;</span><br><span class="line">   CYLBlockExecutor *executor = [CYLBlockExecutor initWithBlock:block];</span><br><span class="line">   objc_setAssociatedObject(self, &quot;runAtDeallocBlockKey&quot;, executor, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CYLBlockExecutor的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithBlock:(voidBlock)aBlock</span><br><span class="line">&#123;</span><br><span class="line">   self = [super init];</span><br><span class="line">   if (self) &#123;</span><br><span class="line">       _block = [aBlock copy];</span><br><span class="line">   &#125;</span><br><span class="line">   return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">   _block ? _block() : nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-property中有哪些属性关键字"><a href="#9-property中有哪些属性关键字" class="headerlink" title="9.@property中有哪些属性关键字"></a>9.@property中有哪些属性关键字</h3><ol>
<li>原子性：atomic、nonatomic</li>
<li>读写权限：readwrite、readonly</li>
<li>内存管理语义：strong、weak、assign、copy、unsafe_unretained</li>
<li>方法名: getter=<name>, setter=<name></name></name></li>
</ol>
<h3 id="10-weak属性需要在dealloc中置为nil吗？"><a href="#10-weak属性需要在dealloc中置为nil吗？" class="headerlink" title="10.weak属性需要在dealloc中置为nil吗？"></a>10.weak属性需要在dealloc中置为nil吗？</h3><p>不需要，ARC会自动处理的</p>
<h3 id="11-synthesize和-dynamic分别有什么作用？"><a href="#11-synthesize和-dynamic分别有什么作用？" class="headerlink" title="11.@synthesize和@dynamic分别有什么作用？"></a>11.@synthesize和@dynamic分别有什么作用？</h3><ol>
<li>@property有两个对应的词：@synthesize和@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是@synthesize var = _var;</li>
<li>@synthesize的语义是如果你没有实现getter和setter那么编译器会自动帮你实现这两个方法</li>
<li>@dynamic是告诉编译器：属性的getter和setter由开发者自己实现。@dynamic一般用来实现动态绑定，需要重写<code>+ (BOOL) resolveInstanceMethod:(SEL)sel</code>方法</li>
</ol>
<h3 id="12-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><a href="#12-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？" class="headerlink" title="12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"></a>12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h3><h3 id="13-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"><a href="#13-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？" class="headerlink" title="13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"></a>13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h3><h3 id="14-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？"><a href="#14-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？" class="headerlink" title="14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？"></a>14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</h3><h3 id="15-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？"><a href="#15-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？" class="headerlink" title="15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？"></a>15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3><h3 id="16-objc中向一个nil对象发送消息将会发生什么？"><a href="#16-objc中向一个nil对象发送消息将会发生什么？" class="headerlink" title="16. objc中向一个nil对象发送消息将会发生什么？"></a>16. objc中向一个nil对象发送消息将会发生什么？</h3><p> objc在想一个对象发送消息时，runtime会根据对象的<code>isa</code>指针找到该对象所属的类，然后再该类的方法列表和其父类的方列表里查找响应的方法，然后再发送消息的时候，objc_msgSend不会有返回值，所谓的返回值都是在发生方法调用的时候执行的。如果向nil对象发送消息，首先就会在寻找对象的<code>isa</code>指针时就返回了，也就不会发生任何错误了</p>
<h3 id="17-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？"><a href="#17-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？" class="headerlink" title="17. objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？"></a>17. objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h3><p>[objc foo]会在编译时，被转意为：objc_msgSend(obj, @selector(foo))</p>
<h3 id="18-什么情况下会报unrecognized-selector异常"><a href="#18-什么情况下会报unrecognized-selector异常" class="headerlink" title="18. 什么情况下会报unrecognized selector异常"></a>18. 什么情况下会报unrecognized selector异常</h3><p>这就涉及到消息的发送流程了：</p>
<ol>
<li>objc在向一个对象发送消息时，Runtime会根据对象的isa指针找到对象所属的类，然后从方法缓存里查找对应的方法</li>
<li>若上一步找不到对应的方法，则会从方法列表里查找，如果还是找不到就会到父类的方法列表里查找直到NSObject类</li>
<li>这时如果还是找不到，就会触发Method resolution，这时你有机会提供一个函数的实现，添加到类中，如果添加了实现，这时就会重新启动一次消息发送流程，Method resolution没有提供实现的函数的话，就会触发消息转发</li>
<li>Fast Forwarding：如果目前对象实现了-forwardingForSelector方法，Runtime就会调用该方法，让目标对象提供一个可以响应该消息的对象，只要不返回nil或者self，就会重新触发消息发送</li>
<li>Normal Forwarding：Fast Forwarding失败了的话，就是启动Normal Forwarding。首先Runtime会发送-methodForSignaturForSelector：消息获取函数的参数和返回值，然后创建一个NSInvocation对象并发送 -forwardInvocation:消息给目标对象</li>
</ol>
<p>如果以上流程走完，仍没有响应消息的函数，则会报unrecognized selector异常</p>
<h3 id="19-一个objc对象如何进行内存布局？（考虑有父类的情况）"><a href="#19-一个objc对象如何进行内存布局？（考虑有父类的情况）" class="headerlink" title="19. 一个objc对象如何进行内存布局？（考虑有父类的情况）"></a>19. 一个objc对象如何进行内存布局？（考虑有父类的情况）</h3><ul>
<li>父类的成员变量和自己的成员变量都存放在该对象的存错空间中</li>
<li><p>对象的内部有一个isa指针，指向他的类对象。类对象中存放着： </p>
<pre><code>* 每个对象的方法列表
* 成员变量的列表
* 属性的列表
* 类对象的内部也有一个isa指针指向元类对象（meta class），元类对象中存放着类方法列表，类对象内部还有一个superclass指针指向父类对象
</code></pre></li>
</ul>
<p><img src="media/15230746670632/15231080093572.jpg" alt=""></p>
<h3 id="20-一个objc对象的isa的指针指向什么？有什么作用？"><a href="#20-一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="20.一个objc对象的isa的指针指向什么？有什么作用？"></a>20.一个objc对象的isa的指针指向什么？有什么作用？</h3><p>指向类对象，可以查找对象上的方法</p>
<h3 id="21-下面的代码输出什么"><a href="#21-下面的代码输出什么" class="headerlink" title="21. 下面的代码输出什么"></a>21. 下面的代码输出什么</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation Son:Father</span><br><span class="line">-(id) init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if(self)&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass[self class]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass[super class]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考察的知识点：self与super关键字</p>
<p>self是类的隐藏参数，指向当前调用方法的类的实例<br>super并不是指向父类的指针，它和self是指向同一个接收者，不同点在于：</p>
<pre><code>* [self class] 编译后 objc_msgSend(obj, @selector(class))；
* [super class] 编译后 objc_msgSendSuper(obj, @selector(class))；
</code></pre><p>但是最后调用的都是NSObject的这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以最后输出都是 Son</p>
<h3 id="22-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"><a href="#22-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）" class="headerlink" title="22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"></a>22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3><h3 id="23-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？"><a href="#23-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？" class="headerlink" title="23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？"></a>23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3><p>不需要<br>它们会在NSObject -dealloc调用的object_dispose()方法中释放掉</p>
<p>对象的内存释放时间表：</p>
<pre><code>1. 调用release：引用计数变为0
2. 子类调用 -dealloc
3. NSObject 调用-dealloc

4.调用object_dispose()
  * 为C++实例变量们（ivars）调用析构函数
  * 为了ARC状态下的 实例变量们（ivars）调用releas
  * 释放所有使用runtime associate 方法关联的对象
  * 释放所有__weak引用
  * 调用free
</code></pre><h3 id="24-objc中的类方法和实例方法有什么本质区别和联系？"><a href="#24-objc中的类方法和实例方法有什么本质区别和联系？" class="headerlink" title="24. objc中的类方法和实例方法有什么本质区别和联系？"></a>24. objc中的类方法和实例方法有什么本质区别和联系？</h3><h3 id="25-objc-msgForward函数是做什么的？直接调用他会发生什么？"><a href="#25-objc-msgForward函数是做什么的？直接调用他会发生什么？" class="headerlink" title="25. _objc_msgForward函数是做什么的？直接调用他会发生什么？"></a>25. _objc_msgForward函数是做什么的？直接调用他会发生什么？</h3><p><code>_objc_msgForward</code>是用来实现消息转发的：向一个对象发送消息，但它并没有对应的实现的时候，<code>_objc_msgForward</code>会尝试消息转发</p>
<p>直接调用_objc_msgForward是非常危险的事，直接调用<code>_objc_msgForward</code>，会跳过查找IMP的过程，直接出发消息转发，如果用不好会直接导致程序Crash。但是如果用得好，能做很多非常酷的事，比如热修复。</p>
<h3 id="26-runtime如何实现weak变量的自动置nil？"><a href="#26-runtime如何实现weak变量的自动置nil？" class="headerlink" title="26. runtime如何实现weak变量的自动置nil？"></a>26. runtime如何实现weak变量的自动置nil？</h3><p>同第8题 weak的实现</p>
<h3 id="27能否向编译后得到的类增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"><a href="#27能否向编译后得到的类增加实例变量？能否向运行时创建的类中添加实例变量？为什么？" class="headerlink" title="27能否向编译后得到的类增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"></a>27能否向编译后得到的类增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3><ul>
<li>不能向编译后的类增加实例变量</li>
<li>可以向运行时创建的类添加实例变量</li>
</ul>
<p>解释：<br>编译后的类，类结构体中的objc_ivar_list 实例变量链表和实例变量的内存大小 instance_size都已经确定了，所以不能向编译后的类增加实例变量</p>
<p>运行时创建的类可以增加实力变量。不过得在调用<code>objc_allocateClassPair</code>之后，<code>objc_registerClassPair</code>之前。</p>
<p>增加方法则没有限制</p>
<h3 id="28-RunLoop与线程的关系"><a href="#28-RunLoop与线程的关系" class="headerlink" title="28 RunLoop与线程的关系"></a>28 RunLoop与线程的关系</h3><p>RunLoop与线程的紧密相连的，每个线程都有一个对应的RunLoop。<br>不过只有主线程的RunLoop默认是开启的</p>
<p>其他线程的RunLoop默认不开启 必要时得手动获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop*runloop = [NSRunLoop currentRunLoop];</span><br></pre></td></tr></table></figure>
<h3 id="29-RunLoop的mode的作用是什么？"><a href="#29-RunLoop的mode的作用是什么？" class="headerlink" title="29.RunLoop的mode的作用是什么？"></a>29.RunLoop的mode的作用是什么？</h3><p>mode是用来处理不同分组的Source/Timer/Obsever事件的，系统提供的mode有5种：</p>
<ul>
<li><p>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认。空闲状态</p>
</li>
<li><p>UITrackingRunLoopMode：ScrollView的滑动时</p>
</li>
<li><p>GSEventReceiveRunLoopMode</p>
</li>
<li>UIInitializationRunLoopMode：启动时</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合</li>
</ul>
<p>系统公开提供的Mode有两个：</p>
<ul>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认。空闲状态</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合</li>
</ul>
<p>RunLoop只能运行在一种Mode下，如果要切换Mode，需要退出RunLoop再重新启动，当ScrollView滑动时，主线程RunLoop会由NSDefaultRunLoopMode切换为UITrackingRunLoopMode，而以+ scheduledTimerWithTimeInterval…的方式触发的timer，实质上是注册到NSDefaultRunLoopMode的，所以这时候timer会被暂停回调。要想不被暂停，可以将timer注册到NSRunLoopCommonModes下，因为NSDefaultRunLoopMode和UITrackingRunLoopMode都在NSRunLoopCommonModes mode集合中</p>
<h3 id="30-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"><a href="#30-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？" class="headerlink" title="30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"></a>30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3><p>同上一题</p>
<h3 id="31-猜想runloop内部是如何实现的？"><a href="#31-猜想runloop内部是如何实现的？" class="headerlink" title="31. 猜想runloop内部是如何实现的？"></a>31. 猜想runloop内部是如何实现的？</h3><p>do-while 循环</p>
<ol>
<li>通知Observer即将进入RunLoop</li>
<li>通知Observer即将处理Timer</li>
<li>通知Observer即将处理Source0</li>
<li>处理Source0</li>
<li>如果有Source1跳到9</li>
<li>通知Observer线程即将休眠</li>
<li>休眠等待被唤醒</li>
<li>通知Observer线程刚被唤醒</li>
<li>处理唤醒时受到的消息，跳回2</li>
<li>通知Observer即将退出RunLoop</li>
</ol>
<p>苹果在主线程注册了两个Observer：</p>
<ul>
<li>第一个Observer监听即将进入RunLoop事件：创建自动释放池AutoreleasePool</li>
<li>第二个Observer监听两个事件：<ul>
<li>即将进入休眠 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新的池；</li>
<li>退出RunLoop调用 _objc_autoreleasePoolPush() 释放自动释放池<h3 id="32-objc使用什么机制管理对象内存？"><a href="#32-objc使用什么机制管理对象内存？" class="headerlink" title="32.objc使用什么机制管理对象内存？"></a>32.objc使用什么机制管理对象内存？</h3>引用计数机制来管理对象内存</li>
</ul>
</li>
</ul>
<h3 id="33-ARC通过什么方式帮助开发者管理内存？"><a href="#33-ARC通过什么方式帮助开发者管理内存？" class="headerlink" title="33. ARC通过什么方式帮助开发者管理内存？"></a>33. ARC通过什么方式帮助开发者管理内存？</h3><p>编译期自动插入retain/release/autorelease 运行期</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/UIViewController、UINavigationController以及UITabBarController/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/UIViewController、UINavigationController以及UITabBarController/" itemprop="url">
                  UIViewController、UINavigationController以及UITabBarController
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-01T13:32:01+08:00">2018-04-01</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="UIViewController"><a href="#UIViewController" class="headerlink" title="UIViewController"></a>UIViewController</h2><ul>
<li><p><code>UIViewController</code> 是管理<code>View</code>的一般管理器的基类，它提供了一些<code>View</code>出现或者消失时的回调方法，也就是生命周期。</p>
</li>
<li><p>子类可以通过重载 <code>loadView</code>方法来创建一个自定义的view层级结构</p>
</li>
</ul>
<h2 id="UINavigationController"><a href="#UINavigationController" class="headerlink" title="UINavigationController"></a>UINavigationController</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>UINavigationController</code> 用来管理<code>UIViewController</code>，在多<code>UIViewController</code>中常用。它以栈的形式管理<code>UIViewController</code>。</p>
<p>一般情况下，<code>UINavigationController</code>至少有一个视图控制器，即最少拥有一个根视图控制器。如果不给它添加根视图控制器，界面上也有视图，因为<code>UINavigationController</code>继承自<code>UIViewController</code>，不过此时<code>.view.backgroundColor</code>为<code>nil</code>，即透明</p>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul>
<li>push方法将某个视图控制器压入栈</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用setViewControllers一次压入多个控制器vc1-&gt;vc2-&gt;vc3，会显示最后的控制器vc3(处于栈顶)</li>
<li>使用pop方法可以移除栈顶控制器</li>
<li><code>popToRootViewControllerAnimated</code>回到根控制器</li>
<li>获取被管理的控制器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// 当前管理的所有的控制器</span><br><span class="line">@property(nonatomic,copy) NSArray&lt;__kindof UIViewController *&gt; *viewControllers;</span><br><span class="line"></span><br><span class="line">/// 栈顶控制器</span><br><span class="line">@property(nullable, nonatomic,readonly,strong) UIViewController *topViewController;</span><br><span class="line"></span><br><span class="line">/// 当前可见的VC，可能是topViewController，也可能是当前topViewController present(modal)出来的VC，总而言之就是可见的VC</span><br><span class="line">@property(nullable, nonatomic,readonly,strong) UIViewController *visibleViewController;</span><br></pre></td></tr></table></figure>
<h3 id="导航条"><a href="#导航条" class="headerlink" title="导航条"></a>导航条</h3><p><code>UINavigationController</code>是用来导航的，具体的大部分操作都有导航条来完成。导航条的内容有<code>UIViewController</code>的<code>navigationItem</code>属性决定</p>
<h3 id="UIToolBar-底部工具条"><a href="#UIToolBar-底部工具条" class="headerlink" title="UIToolBar 底部工具条"></a>UIToolBar 底部工具条</h3><p><code>UINavigationController</code>自带了一个工具栏，通过<code>[self.navigationController setToolbarHidden:NO];</code>来显示工具栏，工具栏中的内容可以通过<code>viewController</code>的<code>toolbarItems</code>来设置，显示的顺序和设置的<code>NSArray</code>中存放的顺序一致，每一个<code>UIBarButtonItem</code>对象都可以设定点击事件，可以使用系统提供的很多常用风格的对象，也可以根据需求进行自定义</p>
<h3 id="UINavigationBar、UINavigationItem、UIToolbar与UIBarButtonItem四者关系"><a href="#UINavigationBar、UINavigationItem、UIToolbar与UIBarButtonItem四者关系" class="headerlink" title="UINavigationBar、UINavigationItem、UIToolbar与UIBarButtonItem四者关系"></a>UINavigationBar、UINavigationItem、UIToolbar与UIBarButtonItem四者关系</h3><ul>
<li><code>NavigaitonBar</code>是导航栏，位于屏幕的上方，管理整个<code>NavigationController</code>的<code>navigationItem</code>，它类似<code>navigationcontroller</code>一样提供了一个栈来管理<code>UINavigationItem</code>，在编程时，一般只设置每个控制器的<code>navigationItem</code>属性</li>
<li>一个导航控制器管理多个视图控制器（多个视图控制器共享一个导航控制器），而一个导航控制器只有一个<code>UINavigationBar</code>，被管理的多个视图控制器共享这一个<code>UINavigationBar</code>，只要一个视图控制器改变了<code>UINavigationBar</code>的属性则影响是全局的。每个视图控制器都会有属于自己的<code>UINavigationItem</code>，系统会以懒加载的方式创建一个<code>UINavigationItem</code>显示在<code>UINavigationBar</code>中，改变<code>UINavigationItem</code>只会在当前控制器起作用，不会影响其它控制器。</li>
<li><code>Toolbar</code>显示在屏幕底部，是导航控制器的工具栏，一个导航控制器只有一个，在任何被管理的视图控制器地方改变则会都改变。可以一次性添加多个<code>UIBarButtonItem</code>或按钮（包装成UIBarButtonItem后添加），有一个items数组属性。</li>
<li><code>UIBarButtonItem</code>是<code>UINavigationItem</code>或者<code>Toolbar</code>具体的一个按钮。</li>
</ul>
<h2 id="UITabBarController-标签控制器"><a href="#UITabBarController-标签控制器" class="headerlink" title="UITabBarController 标签控制器"></a>UITabBarController 标签控制器</h2><p>标签控制器，管理一个选择展示界面，可以控制多个controller，无层级关系，标签栏中的每一个标签关联一个自定义的controller，选择标签切换显示相应的controller根视图</p>
<h3 id="UITabBar"><a href="#UITabBar" class="headerlink" title="UITabBar"></a>UITabBar</h3><p>标签栏，每个<code>UITabBarController</code>只有一个标签栏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface UITabBar : UIView</span><br><span class="line"></span><br><span class="line">@property(nullable, nonatomic, weak) id&lt;UITabBarDelegate&gt; delegate;     // weak reference. default is nil</span><br><span class="line"></span><br><span class="line">//UITabBarController中每个controller对应一个UITabBarItem</span><br><span class="line">@property(nullable, nonatomic, copy) NSArray&lt;UITabBarItem *&gt; *items;        // get/set visible UITabBarItems. default is nil. changes not animated. shown in order</span><br><span class="line">@property(nullable, nonatomic, weak) UITabBarItem *selectedItem; // will show feedback based on mode. default is nil</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="模态视图-modal"><a href="#模态视图-modal" class="headerlink" title="模态视图 modal"></a>模态视图 modal</h2><h3 id="模态视图的作用"><a href="#模态视图的作用" class="headerlink" title="模态视图的作用"></a>模态视图的作用</h3><ol>
<li>收集用户输入信息</li>
<li>临时呈现一些内容</li>
<li>临时改变工作模式</li>
<li>相应设备方向变化（用于针对不同方向分别是想两个ViewController的情况）</li>
<li>显示一个新的view层级</li>
</ol>
<p>这几种情形都会暂时中断程序正常的执行流程，主要作用是收集或者显示一些信息。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/10/ASDK渲染原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/ASDK渲染原理/" itemprop="url">
                  ASDK渲染原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-10T13:32:01+08:00">2018-03-10</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h3><h3 id="UIView的生命周期"><a href="#UIView的生命周期" class="headerlink" title="UIView的生命周期"></a>UIView的生命周期</h3><p>某个视图的层次一改变,该视图就会收到一次回调。</p>
<ol>
<li>调用addSubivew:成功后会给该视图发送didAddSubivew:回调,触发UIView的子类在心增视图时执行其他操作。</li>
<li>didMoveToSuperview:会通知相关视图他们的上级视图已经变化。添加和移除都会调用,所以要判断 superView在不在</li>
<li>视图移动前会发出willMoveToSuperview:回调</li>
<li>didMoveToWindow:回调和didMoveToSuperview:相似,从命名上能看出其区别。</li>
<li>willMoveToWindow:在视图移动前发出的回调。</li>
<li>willRemoveToSubview:回调通知父视图子视图即将被删除</li>
</ol>
<h2 id="ASDK渲染过程"><a href="#ASDK渲染过程" class="headerlink" title="ASDK渲染过程"></a>ASDK渲染过程</h2><h3 id="主要流程简介"><a href="#主要流程简介" class="headerlink" title="主要流程简介"></a>主要流程简介</h3><p>ASDK的渲染过程主要分为4条主线</p>
<ol>
<li>初始化ASDisplayNode对应的UIView或者CALayer</li>
<li>在当前视图进入视图层级时，执行setDisplay方法</li>
<li>display方法执行时，想后台线程分发绘制事物</li>
<li>注册主线层RunLoop的观察者，在每个RunLoop结束时回调</li>
</ol>
<h4 id="初始化ASDisplayNode对应的UIView或者CALayer"><a href="#初始化ASDisplayNode对应的UIView或者CALayer" class="headerlink" title="初始化ASDisplayNode对应的UIView或者CALayer"></a>初始化ASDisplayNode对应的UIView或者CALayer</h4><h4 id="在当前视图进入视图层级时，执行setDisplay方法"><a href="#在当前视图进入视图层级时，执行setDisplay方法" class="headerlink" title="在当前视图进入视图层级时，执行setDisplay方法"></a>在当前视图进入视图层级时，执行setDisplay方法</h4><h4 id="display方法执行时，想后台线程分发绘制事物"><a href="#display方法执行时，想后台线程分发绘制事物" class="headerlink" title="display方法执行时，想后台线程分发绘制事物"></a>display方法执行时，想后台线程分发绘制事物</h4><p>派发异步绘制任务（_ASDisplayLayer）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)display</span><br><span class="line">&#123;</span><br><span class="line">  ASDisplayNodeAssertMainThread();</span><br><span class="line">  [self _hackResetNeedsDisplay];</span><br><span class="line"></span><br><span class="line">  if (self.displaySuspended) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [self display:self.displaysAsynchronously];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)display:(BOOL)asynchronously</span><br><span class="line">&#123;</span><br><span class="line">  if (CGRectIsEmpty(self.bounds)) &#123;</span><br><span class="line">    _attemptedDisplayWhileZeroSized = YES;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  [self.asyncDelegate displayAsyncLayer:self asynchronously:asynchronously];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是通过delegate的代理了派发流程<br>派发流程（ASDisplayNode + AsyncDisplay）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">- (void)displayAsyncLayer:(_ASDisplayLayer *)asyncLayer asynchronously:(BOOL)asynchronously</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">  CALayer *layer = _layer;</span><br><span class="line">  BOOL rasterizesSubtree = _flags.rasterizesSubtree;</span><br><span class="line">  </span><br><span class="line">  __instanceLock__.unlock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  asyncdisplaykit_async_transaction_operation_block_t displayBlock = [self _displayBlockWithAsynchronous:asynchronously isCancelledBlock:isCancelledBlock rasterizing:NO];</span><br><span class="line">  </span><br><span class="line">  if (!displayBlock) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">  asyncdisplaykit_async_transaction_operation_completion_block_t completionBlock = ^(id&lt;NSObject&gt; value, BOOL canceled)&#123;</span><br><span class="line">    ASDisplayNodeCAssertMainThread();</span><br><span class="line">    if (!canceled &amp;&amp; !isCancelledBlock()) &#123;</span><br><span class="line">      UIImage *image = (UIImage *)value;</span><br><span class="line">      BOOL stretchable = (NO == UIEdgeInsetsEqualToEdgeInsets(image.capInsets, UIEdgeInsetsZero));</span><br><span class="line">      if (stretchable) &#123;</span><br><span class="line">        ASDisplayNodeSetResizableContents(layer, image);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        layer.contentsScale = self.contentsScale;</span><br><span class="line">        layer.contents = (id)image.CGImage;</span><br><span class="line">      &#125;</span><br><span class="line">      [self didDisplayAsyncLayer:self.asyncLayer];</span><br><span class="line">      </span><br><span class="line">      if (rasterizesSubtree) &#123;</span><br><span class="line">        ASDisplayNodePerformBlockOnEverySubnode(self, NO, ^(ASDisplayNode * _Nonnull node) &#123;</span><br><span class="line">          [node didDisplayAsyncLayer:node.asyncLayer];</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // Call willDisplay immediately in either case</span><br><span class="line">  [self willDisplayAsyncLayer:self.asyncLayer asynchronously:asynchronously];</span><br><span class="line">  </span><br><span class="line">  if (rasterizesSubtree) &#123;</span><br><span class="line">    ASDisplayNodePerformBlockOnEverySubnode(self, NO, ^(ASDisplayNode * _Nonnull node) &#123;</span><br><span class="line">      [node willDisplayAsyncLayer:node.asyncLayer asynchronously:asynchronously];</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (asynchronously) &#123;</span><br><span class="line">    // Async rendering operations are contained by a transaction, which allows them to proceed and concurrently</span><br><span class="line">    // while synchronizing the final application of the results to the layer&apos;s contents property (completionBlock).</span><br><span class="line">    </span><br><span class="line">    // First, look to see if we are expected to join a parent&apos;s transaction container.</span><br><span class="line">    CALayer *containerLayer = layer.asyncdisplaykit_parentTransactionContainer ? : layer;</span><br><span class="line">    </span><br><span class="line">    // In the case that a transaction does not yet exist (such as for an individual node outside of a container),</span><br><span class="line">    // this call will allocate the transaction and add it to _ASAsyncTransactionGroup.</span><br><span class="line">    // It will automatically commit the transaction at the end of the runloop.</span><br><span class="line">    _ASAsyncTransaction *transaction = containerLayer.asyncdisplaykit_asyncTransaction;</span><br><span class="line">    </span><br><span class="line">    // Adding this displayBlock operation to the transaction will start it IMMEDIATELY.</span><br><span class="line">    // The only function of the transaction commit is to gate the calling of the completionBlock.</span><br><span class="line">    [transaction addOperationWithBlock:displayBlock priority:self.drawingPriority queue:[_ASDisplayLayer displayQueue] completion:completionBlock];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    UIImage *contents = (UIImage *)displayBlock();</span><br><span class="line">    completionBlock(contents, NO);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较长，但逻辑比较简单，主要做了三件事情：</p>
<ol>
<li>创建displayBlock，真正逻辑的渲染都在这里</li>
<li>创建completionBlock，completionBlock会在主线程执行，负责将渲染完成的内存显示到屏幕</li>
<li>将以上两个block添加到_ASAsyncTransaction</li>
</ol>
<p>到这里分发的过程就算完成了，以上只是将block添加到了transaction，那block的执行时机是什么时候呢？</p>
<h4 id="注册主线层RunLoop的观察者，在每个RunLoop结束时回调"><a href="#注册主线层RunLoop的观察者，在每个RunLoop结束时回调" class="headerlink" title="注册主线层RunLoop的观察者，在每个RunLoop结束时回调"></a>注册主线层RunLoop的观察者，在每个RunLoop结束时回调</h4><p>上一节中提到的两个block的执行时机，是通过注册主线层RunLoop的观察者来确定的。</p>
<p>_ASAsyncTransaction</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (void)registerTransactionGroupAsMainRunloopObserver:(_ASAsyncTransactionGroup *)transactionGroup</span><br><span class="line">&#123;</span><br><span class="line">  ASDisplayNodeAssertMainThread();</span><br><span class="line">  static CFRunLoopObserverRef observer;</span><br><span class="line">  ASDisplayNodeAssert(observer == NULL, @&quot;A _ASAsyncTransactionGroup should not be registered on the main runloop twice&quot;);</span><br><span class="line">  // defer the commit of the transaction so we can add more during the current runloop iteration</span><br><span class="line">  CFRunLoopRef runLoop = CFRunLoopGetCurrent();</span><br><span class="line">  CFOptionFlags activities = (kCFRunLoopBeforeWaiting | // before the run loop starts sleeping</span><br><span class="line">                              kCFRunLoopExit);          // before exiting a runloop run</span><br><span class="line"></span><br><span class="line">  observer = CFRunLoopObserverCreateWithHandler(NULL,        // allocator</span><br><span class="line">                                                activities,  // activities</span><br><span class="line">                                                YES,         // repeats</span><br><span class="line">                                                INT_MAX,     // order after CA transaction commits</span><br><span class="line">                                                ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">                                                  ASDisplayNodeCAssertMainThread();</span><br><span class="line">                                                  [transactionGroup commit];</span><br><span class="line">                                                &#125;);</span><br><span class="line">  CFRunLoopAddObserver(runLoop, observer, kCFRunLoopCommonModes);</span><br><span class="line">  CFRelease(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码会在<code>RunLoop</code>即将退出或进入休眠时，执行<code>transactionGroup</code>的<code>commit</code>方法。也就是每次<code>RunLoop</code>结束时开始绘制内容</p>
<p>_ASAsyncTransactionGroup</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)commit</span><br><span class="line">&#123;</span><br><span class="line">  ASDisplayNodeAssertMainThread();</span><br><span class="line"></span><br><span class="line">  if ([_containers count]) &#123;</span><br><span class="line">    NSHashTable *containersToCommit = _containers;</span><br><span class="line">    _containers = [NSHashTable hashTableWithOptions:NSHashTableObjectPointerPersonality];</span><br><span class="line"></span><br><span class="line">    for (id&lt;ASAsyncTransactionContainer&gt; container in containersToCommit) &#123;</span><br><span class="line">      // Note that the act of committing a transaction may open a new transaction,</span><br><span class="line">      // so we must nil out the transaction we&apos;re committing first.</span><br><span class="line">      _ASAsyncTransaction *transaction = container.asyncdisplaykit_currentAsyncTransaction;</span><br><span class="line">      container.asyncdisplaykit_currentAsyncTransaction = nil;</span><br><span class="line">      [transaction commit];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ASAsyncTransactionOperation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)commit</span><br><span class="line">&#123;</span><br><span class="line">  ASAsyncTransactionAssertMainThread();</span><br><span class="line">  NSAssert(self.state == ASAsyncTransactionStateOpen, @&quot;You cannot double-commit a transaction&quot;);</span><br><span class="line">  self.state = ASAsyncTransactionStateCommitted;</span><br><span class="line">  </span><br><span class="line">  if ([_operations count] == 0) &#123;</span><br><span class="line">    // Fast path: if a transaction was opened, but no operations were added, execute completion block synchronously.</span><br><span class="line">    if (_completionBlock) &#123;</span><br><span class="line">      _completionBlock(self, NO);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    NSAssert(_group != NULL, @&quot;If there are operations, dispatch group should have been created&quot;);</span><br><span class="line">    </span><br><span class="line">    _group-&gt;notify(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      [self completeTransaction];</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)completeTransaction</span><br><span class="line">&#123;</span><br><span class="line">  ASAsyncTransactionAssertMainThread();</span><br><span class="line">  ASAsyncTransactionState state = self.state;</span><br><span class="line">  if (state != ASAsyncTransactionStateComplete) &#123;</span><br><span class="line">    BOOL isCanceled = (state == ASAsyncTransactionStateCanceled);</span><br><span class="line">    for (ASAsyncTransactionOperation *operation in _operations) &#123;</span><br><span class="line">      [operation callAndReleaseCompletionBlock:isCanceled];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Always set state to Complete, even if we were cancelled, to block any extraneous</span><br><span class="line">    // calls to this method that may have been scheduled for the next runloop</span><br><span class="line">    // (e.g. if we needed to force one in this runloop with -waitUntilComplete, but another was already scheduled)</span><br><span class="line">    self.state = ASAsyncTransactionStateComplete;</span><br><span class="line"></span><br><span class="line">    if (_completionBlock) &#123;</span><br><span class="line">      _completionBlock(self, isCanceled);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码描述了commit流程，目前只看到了上一节中提到的<code>completionBlock</code>在主线程被执行，<code>displayBlock</code>又是什么时候被执行的呢？这就得看<code>ASAsyncTransactionQueue</code>了</p>
<h3 id="ASAsyncTransactionQueue-绘制事物队列"><a href="#ASAsyncTransactionQueue-绘制事物队列" class="headerlink" title="ASAsyncTransactionQueue 绘制事物队列"></a>ASAsyncTransactionQueue 绘制事物队列</h3><p><code>ASAsyncTransactionQueue</code> 是后台绘制线程与主线层之间通信的桥梁，负责将后台绘制完成的内容，通知给主线层显示。其实是一个<strong>生产-消费者</strong>的设计模式，这里有两条生产线：</p>
<ol>
<li>第一条生产线是上一节中提到的<code>display</code>方法中，不停地生产 <code>displayBlock</code></li>
<li>第二条生产线是，主线层RunLoop的观察者不停地生产 <code>GroupNotify</code>，<code>GroupNotify</code>其实是对<code>completionBlock</code>的封装</li>
</ol>
<p>具体消费流程：</p>
<ol>
<li><p>视图进入视图层时，也就是<code>_ASDisplayView</code>的<code>willMoveToWindow</code>被调用时，对应的CALayer执行<code>setDisplay</code>方法</p>
</li>
<li><p>对应的CALayer的<code>display</code>执行，向后台线程分发绘制事物，将上一节提到两个block添加到_ASAsyncTransaction，并间接调用<code>ASAsyncTransactionQueue</code>的<code>schedule</code>方法</p>
</li>
<li><p><code>schedule</code>方法将<code>displayBlock</code>压入堆栈，然后将<code>displayBlock</code>出栈并执行，执行<code>displayBlock</code>后调用<code>leave</code>方法。<strong>这里为什么要用堆栈呢，主要为了保证最后进入视图层的View，最早被绘制。</strong></p>
</li>
<li><p><code>leave</code>方法会取出第二条生产先产生的<code>notify</code>并执行，也就是在主线程中显示绘制完成的内容。</p>
</li>
</ol>
<p>可以看出，ASDK确实将许多昂贵的操作移出了主线程，有效地加快了视图的绘制与渲染，保证了主线程的流畅性</p>
<h3 id="ASDK是如何提高绘制效率的"><a href="#ASDK是如何提高绘制效率的" class="headerlink" title="ASDK是如何提高绘制效率的"></a>ASDK是如何提高绘制效率的</h3><p>在上一节中，我们了解到了ASDK的渲染流程，主要是通过将<code>displayBlock</code>中的绘制放到后台线程，加快了视图的绘制与渲染，保证了主线程的流畅性。那ASDK又是如何提高绘制效率的呢？<br>先看一下<code>displayBlock</code>的创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">- (asyncdisplaykit_async_transaction_operation_block_t)_displayBlockWithAsynchronous:(BOOL)asynchronous</span><br><span class="line">                                                                    isCancelledBlock:(asdisplaynode_iscancelled_block_t)isCancelledBlock</span><br><span class="line">                                                                         rasterizing:(BOOL)rasterizing</span><br><span class="line">&#123;</span><br><span class="line">  ASDisplayNodeAssertMainThread();</span><br><span class="line"></span><br><span class="line">  if (shouldBeginRasterizing) &#123;</span><br><span class="line">    // Collect displayBlocks for all descendants.</span><br><span class="line">    NSMutableArray *displayBlocks = [NSMutableArray array];</span><br><span class="line">    [self _recursivelyRasterizeSelfAndSublayersWithIsCancelledBlock:isCancelledBlock displayBlocks:displayBlocks];</span><br><span class="line">    CHECK_CANCELLED_AND_RETURN_NIL();</span><br><span class="line">    </span><br><span class="line">    // If [UIColor clearColor] or another semitransparent background color is used, include alpha channel when rasterizing.</span><br><span class="line">    // Unlike CALayer drawing, we include the backgroundColor as a base during rasterization.</span><br><span class="line">    opaque = opaque &amp;&amp; CGColorGetAlpha(backgroundColor.CGColor) == 1.0f;</span><br><span class="line"></span><br><span class="line">    displayBlock = ^id&#123;</span><br><span class="line">      CHECK_CANCELLED_AND_RETURN_NIL();</span><br><span class="line">      </span><br><span class="line">      UIGraphicsBeginImageContextWithOptions(bounds.size, opaque, contentsScaleForDisplay);</span><br><span class="line"></span><br><span class="line">      for (dispatch_block_t block in displayBlocks) &#123;</span><br><span class="line">        CHECK_CANCELLED_AND_RETURN_NIL(UIGraphicsEndImageContext());</span><br><span class="line">        block();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">      UIGraphicsEndImageContext();</span><br><span class="line"></span><br><span class="line">      ASDN_DELAY_FOR_DISPLAY();</span><br><span class="line">      return image;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    displayBlock = ^id&#123;</span><br><span class="line">      CHECK_CANCELLED_AND_RETURN_NIL();</span><br><span class="line"></span><br><span class="line">      if (shouldCreateGraphicsContext) &#123;</span><br><span class="line">        UIGraphicsBeginImageContextWithOptions(bounds.size, opaque, contentsScaleForDisplay);</span><br><span class="line">        CHECK_CANCELLED_AND_RETURN_NIL( UIGraphicsEndImageContext(); );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      CGContextRef currentContext = UIGraphicsGetCurrentContext();</span><br><span class="line">      UIImage *image = nil;</span><br><span class="line">      </span><br><span class="line">      // For -display methods, we don&apos;t have a context, and thus will not call the _willDisplayNodeContentWithRenderingContext or</span><br><span class="line">      // _didDisplayNodeContentWithRenderingContext blocks. It&apos;s up to the implementation of -display... to do what it needs.</span><br><span class="line">      [self __willDisplayNodeContentWithRenderingContext:currentContext drawParameters:drawParameters];</span><br><span class="line">      </span><br><span class="line">      if (usesImageDisplay) &#123;                                   // If we are using a display method, we&apos;ll get an image back directly.</span><br><span class="line">        image = [self.class displayWithParameters:drawParameters isCancelled:isCancelledBlock];</span><br><span class="line">      &#125; else if (usesDrawRect) &#123;                                // If we&apos;re using a draw method, this will operate on the currentContext.</span><br><span class="line">        [self.class drawRect:bounds withParameters:drawParameters isCancelled:isCancelledBlock isRasterizing:rasterizing];</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      [self __didDisplayNodeContentWithRenderingContext:currentContext image:&amp;image drawParameters:drawParameters backgroundColor:backgroundColor borderWidth:borderWidth borderColor:borderColor];</span><br><span class="line">      </span><br><span class="line">      if (shouldCreateGraphicsContext) &#123;</span><br><span class="line">        CHECK_CANCELLED_AND_RETURN_NIL( UIGraphicsEndImageContext(); );</span><br><span class="line">        image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">        UIGraphicsEndImageContext();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ASDN_DELAY_FOR_DISPLAY();</span><br><span class="line">      return image;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return displayBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可看到ASDK根据<code>shouldBeginRasterizing</code>将<code>displayBlock</code>指向了不同的block。</p>
<h4 id="栅格化"><a href="#栅格化" class="headerlink" title="栅格化"></a>栅格化</h4><p><code>shouldBeginRasterizing</code>是栅格化的一个属性，当它为<code>true</code>时，ASDK会将子视图递归的绘制在父视图上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">if (shouldBeginRasterizing) &#123;</span><br><span class="line">    // Collect displayBlocks for all descendants.</span><br><span class="line">    NSMutableArray *displayBlocks = [NSMutableArray array];</span><br><span class="line">    [self _recursivelyRasterizeSelfAndSublayersWithIsCancelledBlock:isCancelledBlock displayBlocks:displayBlocks];</span><br><span class="line">    CHECK_CANCELLED_AND_RETURN_NIL();</span><br><span class="line">    </span><br><span class="line">    // If [UIColor clearColor] or another semitransparent background color is used, include alpha channel when rasterizing.</span><br><span class="line">    // Unlike CALayer drawing, we include the backgroundColor as a base during rasterization.</span><br><span class="line">    opaque = opaque &amp;&amp; CGColorGetAlpha(backgroundColor.CGColor) == 1.0f;</span><br><span class="line"></span><br><span class="line">    displayBlock = ^id&#123;</span><br><span class="line">      CHECK_CANCELLED_AND_RETURN_NIL();</span><br><span class="line">      </span><br><span class="line">      UIGraphicsBeginImageContextWithOptions(bounds.size, opaque, contentsScaleForDisplay);</span><br><span class="line"></span><br><span class="line">      for (dispatch_block_t block in displayBlocks) &#123;</span><br><span class="line">        CHECK_CANCELLED_AND_RETURN_NIL(UIGraphicsEndImageContext());</span><br><span class="line">        block();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">      UIGraphicsEndImageContext();</span><br><span class="line"></span><br><span class="line">      ASDN_DELAY_FOR_DISPLAY();</span><br><span class="line">      return image;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h4><p>这种方式更多的适用于图片节点<code>ASImageNode</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (asyncdisplaykit_async_transaction_operation_block_t)_displayBlockWithAsynchronous:(BOOL)asynchronous isCancelledBlock:(asdisplaynode_iscancelled_block_t)isCancelledBlock rasterizing:(BOOL)rasterizing &#123;</span><br><span class="line">  asyncdisplaykit_async_transaction_operation_block_t displayBlock = nil;</span><br><span class="line">  ASDisplayNodeFlags flags = _flags;</span><br><span class="line"></span><br><span class="line">  if (!rasterizing &amp;&amp; self.shouldRasterizeDescendants) &#123;</span><br><span class="line">	#：栅格化</span><br><span class="line">  &#125; else if (flags.implementsInstanceImageDisplay || flags.implementsImageDisplay) &#123;</span><br><span class="line">	id drawParameters = [self drawParameters];</span><br><span class="line">	</span><br><span class="line">	displayBlock = ^id&#123;</span><br><span class="line">	  UIImage *result = nil;</span><br><span class="line">	  if (flags.implementsInstanceImageDisplay) &#123;</span><br><span class="line">		result = [self displayWithParameters:drawParameters isCancelled:isCancelledBlock];</span><br><span class="line">	  &#125; else &#123;</span><br><span class="line">		result = [[self class] displayWithParameters:drawParameters isCancelled:isCancelledBlock];</span><br><span class="line">	  &#125;</span><br><span class="line">	  return result;</span><br><span class="line">	&#125;;</span><br><span class="line">  &#125; else if (flags.implementsInstanceDrawRect || flags.implementsDrawRect) &#123;</span><br><span class="line">	#：提供 context，使用 CG 绘图</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return [displayBlock copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用GC绘制"><a href="#使用GC绘制" class="headerlink" title="使用GC绘制"></a>使用GC绘制</h4><p>文字的绘制一般都会在<code>- drawRect:withParameters:isCancelled:isRasterizing:</code>进行，这个方法只是提供了一个合适的用于绘制的上下文，该方法不止可以绘制文字，只是在这里绘制文字比较常见：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (asyncdisplaykit_async_transaction_operation_block_t)_displayBlockWithAsynchronous:(BOOL)asynchronous isCancelledBlock:(asdisplaynode_iscancelled_block_t)isCancelledBlock rasterizing:(BOOL)rasterizing &#123;</span><br><span class="line">  asyncdisplaykit_async_transaction_operation_block_t displayBlock = nil;</span><br><span class="line">  ASDisplayNodeFlags flags = _flags;</span><br><span class="line"></span><br><span class="line">  if (!rasterizing &amp;&amp; self.shouldRasterizeDescendants) &#123;</span><br><span class="line">	#：栅格化</span><br><span class="line">  &#125; else if (flags.implementsInstanceImageDisplay || flags.implementsImageDisplay) &#123;</span><br><span class="line">	#：绘制 UIImage</span><br><span class="line">  &#125; else if (flags.implementsInstanceDrawRect || flags.implementsDrawRect) &#123;</span><br><span class="line">	  if (!rasterizing) &#123;</span><br><span class="line">		UIGraphicsBeginImageContextWithOptions(bounds.size, opaque, contentsScaleForDisplay);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  if (flags.implementsInstanceDrawRect) &#123;</span><br><span class="line">		[self drawRect:bounds withParameters:drawParameters isCancelled:isCancelledBlock isRasterizing:rasterizing];</span><br><span class="line">	  &#125; else &#123;</span><br><span class="line">		[[self class] drawRect:bounds withParameters:drawParameters isCancelled:isCancelledBlock isRasterizing:rasterizing];</span><br><span class="line">	  &#125;</span><br><span class="line">	  </span><br><span class="line">	  UIImage *image = nil;</span><br><span class="line">	  if (!rasterizing) &#123;</span><br><span class="line">		image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">		UIGraphicsEndImageContext();</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  return image;</span><br><span class="line">	&#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="ASNetworkImageNode"><a href="#ASNetworkImageNode" class="headerlink" title="ASNetworkImageNode"></a>ASNetworkImageNode</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>一般的使用方法，初始化并设置一个图片URL就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ASNetworkImageNode *imageNode = [[ASNetworkImageNode alloc] init];</span><br><span class="line">imageNode.URL = [NSURL URLWithString:@&quot;https://someurl.com/image_uri&quot;];</span><br></pre></td></tr></table></figure>
<p>ASNetworkImageNode的<code>setURL</code>方法最终调用的其实是<code>- (void)setURLs: resetToDefault:</code>方法</p>
<p><code>- (void)setURLs: resetToDefault:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)setURLs:(NSArray &lt;NSURL *&gt; *)URLs resetToDefault:(BOOL)reset&#123;</span><br><span class="line">    [self _locked_cancelImageDownloadWithResumePossibility:NO];</span><br><span class="line">    [self setNeedsPreload];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做了两件事情：</p>
<ol>
<li>取消上一张图片的下载，取消下载就是通过调用<code>_downloader</code> 的<code>cancelImageDownloadForIdentifier</code>方法来取消</li>
</ol>
<ol start="2">
<li>预加载图片，预加载则是将创建<code>_downloader</code>的任务封装block扔到队列里，让异步线程去执行。</li>
</ol>
<h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><p>ASNetworkImageNode调用链<br><img src="https://raw.githubusercontent.com/Mochangxing/blogImages/master/media/15196252410771/15206971565240.jpg" alt=""></p>
<p>可以看到ASNetworkImageNode在<code>willMoveToWindow</code>方法中，间接调用到了<code>_downloadImageWithCompletion</code>方法，该方法实际上是将下载图片的block抛给异步线程处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)_downloadImageWithCompletion:(void (^)(id &lt;ASImageContainerProtocol&gt; imageContainer, NSError*, id downloadIdentifier))finished</span><br><span class="line">&#123;</span><br><span class="line">   ASPerformBlockOnBackgroundThread(^&#123;</span><br><span class="line">        //下载网络图片</span><br><span class="line">         _downloadIdentifier = [_downloader downloadImageWithURLs:urls</span><br><span class="line">                                                callbackQueue:dispatch_get_main_queue()</span><br><span class="line">                                             downloadProgress:NULL</span><br><span class="line">                                                   completion:^(id &lt;ASImageContainerProtocol&gt; _Nullable imageContainer, NSError * _Nullable error, id  _Nullable downloadIdentifier) &#123;</span><br><span class="line">                                                     if (finished != NULL) &#123;</span><br><span class="line">                                                       finished(imageContainer, error, downloadIdentifier);</span><br><span class="line">                                                     &#125;</span><br><span class="line">                                                   &#125;];   </span><br><span class="line">   &#125;); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void ASPerformBlockOnBackgroundThread(void (^block)(void))</span><br><span class="line">&#123;</span><br><span class="line">  if (block == nil)&#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (ASDisplayNodeThreadIsMain()) &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), block);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    block();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么ASNetworkImageView的图片加载逻辑是：</p>
<p><strong>视图进入视图层（willMoveToWindow）-&gt; 将下载图片封装成任务丢给异步线程（_downloadImageWithCompletion）-&gt; 异步下载完成后，将图片渲染到屏幕，也就是在传给<code>-downloadImageWithURLs:                       callbackQueue: downloadProgress: completion:;</code> 方法的<code>completion</code> block中将图片设置到ASNetworkImageView的</strong></p>
<p>这个<code>completion</code>block是在 <code>- (void)_lazilyLoadImageIfNecessary</code>方法中创建并传给<code>_downloadImageWithCompletion</code>的</p>
<p><code>completion</code>block代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auto finished = ^(id &lt;ASImageContainerProtocol&gt;imageContainer, NSError *error, id downloadIdentifier, ASNetworkImageSource imageSource) &#123;</span><br><span class="line">     if (imageContainer != nil) &#123;</span><br><span class="line">         [strongSelf _locked_setCurrentImageQuality:1.0];</span><br><span class="line">         if ([imageContainer asdk_animatedImageData] &amp;&amp; strongSelf-&gt;_downloaderFlags.downloaderImplementsAnimatedImage) &#123;</span><br><span class="line">           id animatedImage = [strongSelf-&gt;_downloader animatedImageWithData:[imageContainer asdk_animatedImageData]];</span><br><span class="line">           [strongSelf _locked_setAnimatedImage:animatedImage];</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">           [strongSelf _locked__setImage:[imageContainer asdk_image]];</span><br><span class="line">         &#125;</span><br><span class="line">         strongSelf-&gt;_imageLoaded = YES;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>事实上在<code>_locked__setImage:</code>方法中又会调用<code>setNeedsDisplay</code>方法，从而触发上一节讲到的异步渲染逻辑。</p>
<h3 id="使用过程中存在的坑"><a href="#使用过程中存在的坑" class="headerlink" title="使用过程中存在的坑"></a>使用过程中存在的坑</h3><p>通过前面两个小节可以发现，<code>_downloader</code>的创建以及<code>cancel</code>其实是在不同的线程里执行的。那么就有可能存在<code>cancelImageDownloadForIdentifier</code>会在<code>_downloader</code>创建之前执行，从而导致加载失效URL的情况，在页面快速滚动的时候会造成UIView的闪烁，以及产生性能问题，造成卡顿。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/27/Objective-C高级编程+iOS与OS+X多线程和内存管理 读书笔记之 block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/27/Objective-C高级编程+iOS与OS+X多线程和内存管理 读书笔记之 block/" itemprop="url">
                  Objective-C高级编程+iOS与OS+X多线程和内存管理 读书笔记之 block
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-27T13:32:01+08:00">2018-01-27</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="block概要"><a href="#block概要" class="headerlink" title="block概要"></a>block概要</h2><p><img src="media/15170297966756/15170682755746.jpg" alt=""></p>
<blockquote>
<p>概念：block是带有<strong>自动变量</strong>的<strong>匿名函数</strong></p>
</blockquote>
<h2 id="block模式"><a href="#block模式" class="headerlink" title="block模式"></a>block模式</h2><h3 id="1-语法："><a href="#1-语法：" class="headerlink" title="1. 语法："></a>1. 语法：</h3><p><code>^</code> <code>返回值类型（可省略）`</code>参数列表<code></code>表达式`</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ int (int count) &#123;</span><br><span class="line">    return count + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-block类型变量"><a href="#2-block类型变量" class="headerlink" title="2. block类型变量"></a>2. block类型变量</h3><p>当函数参数与返回值使用block类型时，记述方式比较复杂，可以用 <strong>typedef</strong> 来解决</p>
<p><code>typedef int (^block_t)(int);</code><br><code>void func(block_t block)</code><br><code>block_t func()</code></p>
<h3 id="3-自动截获变量"><a href="#3-自动截获变量" class="headerlink" title="3.自动截获变量"></a>3.自动截获变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // insert code here...</span><br><span class="line">        </span><br><span class="line">        int a = 0;</span><br><span class="line">        void(^block)(void) = ^()&#123;</span><br><span class="line">            NSLog(@&quot;%d&quot;, a);</span><br><span class="line">        &#125;;</span><br><span class="line">        a = 1;</span><br><span class="line">        block();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印的出来的是 0</p>
<blockquote>
<p>block表达式截获所使用的自动变量的值，即保存自动变量的瞬时值</p>
</blockquote>
<h3 id="4-block修饰符"><a href="#4-block修饰符" class="headerlink" title="4. __block修饰符"></a>4. __block修饰符</h3><p>block只能截获自动变的瞬时值，但不能给自动变量赋值<br>使用__block修饰符的自动变量，可以在block表达式中被赋值 <strong>自动变量截获没有实现对C语言数组的截获， 使用时编译器会报错</strong></p>
<h2 id="block实现"><a href="#block实现" class="headerlink" title="block实现"></a>block实现</h2><p>编译前源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // insert code here...</span><br><span class="line">        int a = 0;</span><br><span class="line">        void(^block)(void) = ^()&#123;</span><br><span class="line">            printf(&quot;%d&quot;, a);</span><br><span class="line">        &#125;;</span><br><span class="line">        a = 1;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int a = 0;</span><br><span class="line">        void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</span><br><span class="line">        a = 1;</span><br><span class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看看 __main_block_func_0 的定义 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    // 我们的源码的编译后的函数体，值引用了变量 a</span><br><span class="line">  int a = __cself-&gt;a; // bound by copy</span><br><span class="line">            </span><br><span class="line">            printf(&quot;%d&quot;, a);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>那 <strong>main_block_impl_0 又是什么呢 ，看一下声明
</strong>main_block_impl_0是一个结构体，有三个成员</p>
<ol>
<li>struct <strong>block_impl impl // 结构体 </strong>block_impl 应该是block的本质</li>
<li>struct __main_block_desc_0 Desc</li>
<li>int a</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl; </span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int a;</span><br></pre></td></tr></table></figure>
<p>再看看结构体 __block_impl 的定义，四个成员</p>
<ol>
<li>isa指针</li>
<li>Flags</li>
<li>Reserved</li>
<li>函数指针FuncPtr，函数指针指向源码编译后生成的函数，也就是__main_block_func_0</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再回头看看__main_block_impl_0 的构造函数：</p>
<p>主要是 给<strong>block_impl赋值，以及截获自动变量。可以看到</strong>block_impl的isa指针被赋值为_NSConcreteStackBlock </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体<strong>main_block_impl_0还有一个成员没有分析到： struct </strong>main_block_desc_0* Desc;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>
<p>根据成员变量和构造函数，很容易看出，只要是描述了 __main_block_impl_0 的实例大小</p>
<p>至此，所有相关的结构体都分析了，回过头来看看，编译后的源码<br>再贴一下，翻回去再翻回来挺累的，去掉了转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int a = 0;</span><br><span class="line">        // 构造block</span><br><span class="line">        void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</span><br><span class="line">        a = 1;</span><br><span class="line">       </span><br><span class="line">       // 调用block， FuncPtr也就是__main_block_func_0 入参就是blcok </span><br><span class="line">        block-&gt;FuncPtr(block)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就很清楚了，其实就是编译器生成了FuncPtr函数和block结构体，结构体值引用了自动变量（所以说是<strong>截获自动变量</strong>），调用的时候执行下FuncPtr。还有一个问题 _NSConcreteStackBlock 是个什么类？</p>
<h2 id="block-说明符"><a href="#block-说明符" class="headerlink" title="__block 说明符"></a>__block 说明符</h2><p>block中给变量赋值编译会报错。两种情况下允许在block中进行赋值操作。</p>
<ol>
<li>全局变量、静态全局变量和静态变量</li>
<li>__block 说明符修饰的变量</li>
</ol>
<p><strong>全局变量与全局静态变量，在block中是直接使用</strong><br><strong>静态变量则是是用静态变量的指针进行访问</strong></p>
<p>__block 说明符编译后</p>
<p>编译前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // insert code here...</span><br><span class="line">        __block int a = 3;</span><br><span class="line">        void(^block)(void) = ^()&#123;</span><br><span class="line">            a *=2;</span><br><span class="line">        &#125;;</span><br><span class="line">        block();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">    // __block int a = 3 变成了 __Block_byref_a_0 结构体 并初始化为3 </span><br><span class="line">        __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 3&#125;;</span><br><span class="line">        // 初始化block </span><br><span class="line">        void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344));</span><br><span class="line">        // 执行block</span><br><span class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要变化在<strong>main_block_impl_0 结构体，变量a 不在是一个int 而是</strong>Block_byref_a_0 结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_a_0 *a; // by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>来看看__Block_byref_a_0 </p>
<p><code>__attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 3};</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_a_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到结构体中的__forwarding 就是指向了自身 int a 被初始化为3<br>放一张图来说明<br><img src="media/15170297966756/15173167442930.jpg" alt=""></p>
<h2 id="block的存储域"><a href="#block的存储域" class="headerlink" title="block的存储域"></a>block的存储域</h2><p>问题：</p>
<ol>
<li>block超出变量作用域可以存在的原因</li>
</ol>
<p>答案：block从栈上复制到了对堆</p>
<ol start="2">
<li><strong>forwarding的作用是什么<br>答案：</strong>forwarding保证不管block被分配的堆上还是在栈上，都能被访问到</li>
</ol>
<h2 id="block变量的存储域"><a href="#block变量的存储域" class="headerlink" title="__block变量的存储域"></a>__block变量的存储域</h2><h2 id="截获对象"><a href="#截获对象" class="headerlink" title="截获对象"></a>截获对象</h2><h2 id="block变量与对象"><a href="#block变量与对象" class="headerlink" title="__block变量与对象"></a>__block变量与对象</h2>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/25/objective_c 中__weak的实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/25/objective_c 中__weak的实现原理/" itemprop="url">
                  objective_c 中__weak的实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-25T13:32:01+08:00">2018-01-25</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="weak引用表，是一张hash表。key为对象的地址，value为所有指向该对象的弱引用指针。"><a href="#weak引用表，是一张hash表。key为对象的地址，value为所有指向该对象的弱引用指针。" class="headerlink" title="weak引用表，是一张hash表。key为对象的地址，value为所有指向该对象的弱引用指针。"></a><strong>weak引用表，是一张hash表。key为对象的地址，value为所有指向该对象的弱引用指针。</strong></h1><ul>
<li>实现过程,objc_initWeak</li>
<li>SideTable</li>
<li><strong>weak使用注意事项：如果大量使用</strong>weak修饰符修饰的变量是，最好先赋值给__strong修饰符变量再使用。至于原因下文会详细说明。</li>
<li>weak引用表的释放</li>
</ul>
<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id obj = [NSObject new];</span><br><span class="line">id __weak obj1 = obj ;</span><br></pre></td></tr></table></figure>
<p>编译器编译后：</p>
<figure class="highlight plain"><figcaption><span>obj;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_initWeak(&amp;obj1, obj);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></table></figure>
<p>  <strong>通过objc_initWeak 初始化objc1变量，变量objc1超出作用于后通过objc_destroyWeak释放objc1.</strong></p>
<h2 id="objc-initWeak初始化"><a href="#objc-initWeak初始化" class="headerlink" title="objc_initWeak初始化"></a>objc_initWeak初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">id objc_initWeak(id *location, id newObj) </span><br><span class="line">   &#123;    </span><br><span class="line">   //首先判断newObj是否为nil,是则直接返回。 </span><br><span class="line">       if (!newObj) &#123;</span><br><span class="line">            *location = nil;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        return storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">           (location, (objc_object*)newObj);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>storeWeak函数 Update a weak variable. 更新弱引用变量，忽略多线程资源竞争逻辑，主要分为三步：</p>
<ol>
<li>声明新旧两个SideTabel对象，分别代表旧的weak引用表与新的weak引用表</li>
<li>如果weak引用已经有所指向，则将weak引用从旧对象的weak引用表中清除</li>
<li>如果weak引用有新的指向，则将weak引用的注册到新对象的weak引用表中</li>
</ol>
<blockquote>
<p>haveOld 弱引用是否已经有所指向<br>haveNew 是否有新的指向<br>CrashIfDeallocating 执行方法时发生Deallocate是否Crash</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line">static id </span><br><span class="line">storeWeak(id *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(haveOld  ||  haveNew);</span><br><span class="line">    if (!haveNew) assert(newObj == nil);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    // 声明旧的弱引用表 与 新的弱引用表 </span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line">    // Acquire locks for old and new values.</span><br><span class="line">    // Order by lock address to prevent lock ordering problems. </span><br><span class="line">    // Retry if the old value changes underneath us.</span><br><span class="line"> retry:</span><br><span class="line">    if (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    if (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevent a deadlock between the weak reference machinery</span><br><span class="line">    // and the +initialize machinery by ensuring that no </span><br><span class="line">    // weakly-referenced object has an un-+initialized isa.</span><br><span class="line">    if (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        if (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            _class_initialize(_class_getNonMetaClass(cls, (id)newObj));</span><br><span class="line"></span><br><span class="line">            // If this class is finished with +initialize then we&apos;re good.</span><br><span class="line">            // If this class is still running +initialize on this thread </span><br><span class="line">            // (i.e. +initialize called storeWeak on an instance of itself)</span><br><span class="line">            // then we may proceed but it will appear initializing and </span><br><span class="line">            // not yet initialized to the check above.</span><br><span class="line">            // Instead set previouslyInitializedClass to recognize it on retry.</span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Clean up old value, if any.</span><br><span class="line">    if (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Assign new value, if any.</span><br><span class="line">    if (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        // weak_register_no_lock returns nil if weak store should be rejected</span><br><span class="line"></span><br><span class="line">        // Set is-weakly-referenced bit in refcount table.</span><br><span class="line">        if (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Do not set *location anywhere else. That would introduce a race.</span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // No new value. The storage is not changed.</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    return (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_destroyWeak 函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">objc_destroyWeak(id *location)</span><br><span class="line">&#123;</span><br><span class="line">    (void)storeWeak&lt;DoHaveOld, DontHaveNew, DontCrashIfDeallocating&gt;</span><br><span class="line">        (location, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="weak引用表的释放"><a href="#weak引用表的释放" class="headerlink" title="weak引用表的释放"></a>weak引用表的释放</h2><p>先上一张图，一图胜千言</p>
<p><img src="https://raw.githubusercontent.com/Mochangxing/blogImages/master/media/15168677855313/15170254377789.jpg" alt=""></p>
<p>objc_object::clearDeallocating()函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    //1、去到weak引用表</span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line">    table.lock();</span><br><span class="line">    if (isa.weakly_referenced) &#123;</span><br><span class="line">    //2、清除所有的weak引用</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.erase(this);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看看weak_clear_no_lock函数的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void </span><br><span class="line">weak_clear_no_lock(weak_table_t *weak_table, id referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    // 1、从weak表中，获取referent_id的 weak引用实体 也就是weak_entry_t</span><br><span class="line">    </span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    if (entry == nil) &#123;</span><br><span class="line">        /// XXX shouldn&apos;t happen, but does with mismatched CF/objc</span><br><span class="line">        //printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // zero out references</span><br><span class="line">    weak_referrer_t *referrers;</span><br><span class="line">    size_t count;</span><br><span class="line">    </span><br><span class="line">    // 2、获取weak_entry_t中的referrers， 也就是所有引用了referent_id 的弱引用对象，这是一个数组</span><br><span class="line">    if (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    // 3、遍历数组，将所有弱引用对象赋值为 nil</span><br><span class="line">    for (size_t i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        if (referrer) &#123;</span><br><span class="line">            if (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (*referrer) &#123;</span><br><span class="line">                _objc_inform(&quot;__weak variable at %p holds %p instead of %p. &quot;</span><br><span class="line">                             &quot;This is probably incorrect use of &quot;</span><br><span class="line">                             &quot;objc_storeWeak() and objc_loadWeak(). &quot;</span><br><span class="line">                             &quot;Break on objc_weak_error to debug.\n&quot;, </span><br><span class="line">                             referrer, (void*)*referrer, (void*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 4、将entry从weak引用表中移除</span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就很清楚了，主要步骤：</p>
<ol>
<li>从weak表中，获取referent_id的 weak引用实体 也就是weak_entry_t</li>
<li>获取weak_entry_t中的referrers， 也就是所有引用了referent_id 的弱引用对象，这是一个数组</li>
<li>遍历数组，将所有弱引用对象赋值为 nil</li>
<li>将entry从weak引用表中移除</li>
</ol>
<p>回答刚开始提出的问题：为什么如果大量使用<strong>weak修饰符修饰的变量时，最好先赋值给</strong>strong修饰符变量再使用？</p>
<p><del>因为<strong>weak修饰符修饰的变量生命周期分为：创建、存储、销毁三个过程，其中还涉及Hash以及数组的遍历等操作。而</strong>strong修饰符只是简单引用计数+1和-1，相对于<strong>strong修饰符来说</strong>weak修饰符更消耗性能。</del></p>
<p>以上不是主要原因，因为使用<strong>weak修饰符修饰的变量时，即是使用注册的autoreleasepool中的变量，这是为了确保</strong>weak变量在使用过程中，不会被置为nil。而如果大量使用<strong>weak变量的话，就会导致</strong>weak变量多次注册到autoreleasepool，为了避免这种情况，最好先赋值给__strong 变量再使用</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/08/iOS运行时Runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/08/iOS运行时Runtime/" itemprop="url">
                  iOS运行时Runtime
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-08T13:32:01+08:00">2017-02-08</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p>SEL是方法选择器，即方法的ID。结构体如下，源码中没有objc_selector具体的定义。<br>但其实就是映射到方法的C字符串。不同类的同名方法具有相同的选择器，方法名相同单变量类型不同也会导致它们具有相同的选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// An opaque type that represents a method selector.</span><br><span class="line"></span><br><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p><code>id</code>的结构体定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">    private:</span><br><span class="line">        isa_t isa;</span><br><span class="line">    </span><br><span class="line">    public:</span><br><span class="line">    </span><br><span class="line">        // ISA() assumes this is NOT a tagged pointer object</span><br><span class="line">        Class ISA();</span><br><span class="line">    </span><br><span class="line">        // getIsa() allows this to be a tagged pointer object</span><br><span class="line">        Class getIsa();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_object</code>结构体包含一个<code>isa_t</code>指针，<code>isa_t</code>是一个联合体，根据<code>isa</code>指针可以找到对象所属的类，<code>isa</code>还涉及到 tagged pointer 的相关知识点。</p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p><code>Class</code> 是一个指向 <code>objc_class</code>结构体的指针<br><code>objc_class</code>继承自 <code>objc_object</code>结构体，<code>objc_class</code>的很多方法都基于它的几个成员实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了处理类与对象的关系，Runtime创造了元类（Meta Class，类对象所属的类型就是元类，它用来表示类本身所具备的元数据。每个类只有一个类对象，每个类对象只对应一个元类</p>
<p>实例对象的<code>isa</code>指针指向类对象的，类对象的<code>isa</code>指针指向元类<br><strong>根元类的<code>isa</code>指针指向的是自己，而超类指向的<code>NSObject</code>，<code>NSObject</code>的超类的为<code>nil</code>，也就是<code>NSObject</code>没有超类</strong><br><img src="media/15177558941335/15188318533816.jpg" alt=""></p>
<h3 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h3><p><code>cache_t</code> 定义如下，方法缓存列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;</span><br><span class="line">    mask_t _occupied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>buckets</code>是一个hask表，存储了调用过的方法体IMP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cache</code>为方法调用进行了性能优化，每次方法调用了先从<code>cache</code>中查找，命中就返回方法体IMP，否则再从<code>isa</code>指向的方法列表遍历查找能够响应消息的方法</p>
<h3 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a>class_data_bits_t</h3><p><code>class_data_bits_t</code>结构体定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line"></span><br><span class="line">    // Values are the FAST_ flags above. </span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    bool getBit(uintptr_t bit)</span><br><span class="line">    &#123;</span><br><span class="line">        return bits &amp; bit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setBits(uintptr_t set) </span><br><span class="line">    &#123;</span><br><span class="line">        uintptr_t oldBits;</span><br><span class="line">        uintptr_t newBits;</span><br><span class="line">        do &#123;</span><br><span class="line">            oldBits = LoadExclusive(&amp;bits);</span><br><span class="line">            newBits = updateFastAlloc(oldBits | set, set);</span><br><span class="line">        &#125; while (!StoreReleaseExclusive(&amp;bits, oldBits, newBits));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void clearBits(uintptr_t clear) </span><br><span class="line">    &#123;</span><br><span class="line">        uintptr_t oldBits;</span><br><span class="line">        uintptr_t newBits;</span><br><span class="line">        do &#123;</span><br><span class="line">            oldBits = LoadExclusive(&amp;bits);</span><br><span class="line">            newBits = updateFastAlloc(oldBits &amp; ~clear, clear);</span><br><span class="line">        &#125; while (!StoreReleaseExclusive(&amp;bits, oldBits, newBits));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>class_data_bits_t</code> 包含了一个 <code>bits</code>，这个指针跟不同的FAST_前缀的flag掩码做按位与操作，获取不同的数据</p>
<p>FAST_前缀的flag掩码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// class is a Swift class</span><br><span class="line">#define FAST_IS_SWIFT           (1UL&lt;&lt;0)</span><br><span class="line">// class or superclass has default retain/release/autorelease/retainCount/</span><br><span class="line">//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</span><br><span class="line">#define FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;1)</span><br><span class="line">// class&apos;s instances requires raw isa</span><br><span class="line">#define FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;2)</span><br><span class="line">// data pointer</span><br><span class="line">#define FAST_DATA_MASK          0x00007ffffffffff8UL</span><br></pre></td></tr></table></figure>
<p><code>bits</code>中其他的Fast_都是存储了相关标志位bool值，<strong>FAST_DATA_MASK</strong> 则存储了指向<code>class_rw_t</code>的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class_rw_t* data() &#123;</span><br><span class="line">     return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h3><p><code>objc_class</code> 包含了 <code>class_data_bits_t</code>， <code>class_data_bits_t</code>存储了 <code>class_rw_t</code>指针， <code>class_rw_t</code>有包含了了 <code>class_ro_t</code></p>
<p><code>class_ro_t</code>的结构体定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    const char * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *baseMethods() const &#123;</span><br><span class="line">        return baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>class_ro_t</code> 中 <code>method_list_t</code>、<code>property_list_t</code>与<code>property_list_t</code>都继承自<code>entsize_list_tt</code>，<code>protocol_list_t</code> 存储了 <code>protocol_ref_t</code>列表（也就是<code>protocol_t</code>指针列表）。<code>class_ro_t</code> 存储的大多都是编译时信息就确定的信息</p>
<h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><p><code>class_rw_t</code>结构体定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    // Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods; </span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    char *demangledName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>class_rw_t</code> 提供了运行时类拓展的能力，而<code>class_ro_t</code>存储的大多是编译时就确定的信息。虽然二者都包含了类的方法、属性以及协议等信息，但列表的实现方式不尽相同。<br><code>class_rw_t</code>中的 <code>method_array_t</code>、<code>property_array_t</code>与<code>protocol_array_t</code> 都继承自<code>list_array_tt</code>,<code>list_array_tt</code>真正的为运行时提供了拓展能力，因为<code>list_array_tt</code>可以存储list指针，内容有三种：</p>
<ol>
<li>空</li>
<li>entsize_list_tt指针</li>
<li>entsize_list_tt指针数组</li>
</ol>
<h3 id="realizeClass"><a href="#realizeClass" class="headerlink" title="realizeClass"></a>realizeClass</h3><h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><h3 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h3><h3 id="objc-property-t"><a href="#objc-property-t" class="headerlink" title="objc_property_t"></a>objc_property_t</h3><h3 id="protocol-t"><a href="#protocol-t" class="headerlink" title="protocol_t"></a>protocol_t</h3><h1 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h1><h3 id="objc-msgSend流程"><a href="#objc-msgSend流程" class="headerlink" title="objc_msgSend流程"></a>objc_msgSend流程</h3><ol>
<li>检测这个<code>selector</code>是否要忽略</li>
<li>检测<code>target</code>是否为<code>nil</code></li>
<li>从<code>cache</code>中查找对应的函数</li>
<li><code>cache</code>找不到，就从方法分发表中查找</li>
<li>方法分发表中还找不到就到超类中查找，直到<code>NSObject</code></li>
<li>如果还找不到就进入<strong>动态方法解析</strong></li>
</ol>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p><img src="media/15177558941335/15188578544407.jpg" alt=""></p>
<h1 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h1><p>#健壮的实例变量 (Non Fragile ivars)</p>
<h1 id="Objective-C-Associated-Objects"><a href="#Objective-C-Associated-Objects" class="headerlink" title="Objective-C Associated Objects"></a>Objective-C Associated Objects</h1><h1 id="Method-Swizzling-方法替换"><a href="#Method-Swizzling-方法替换" class="headerlink" title="Method Swizzling 方法替换"></a>Method Swizzling 方法替换</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/17/Http网络协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/17/Http网络协议/" itemprop="url">
                  Http 网络协议
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-17T13:32:01+08:00">2017-01-17</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h3><p>tcp/ip协议族<br>ip协议<br>tcp协议<br>dns服务<br>uri与url</p>
<h3 id="简单http协议"><a href="#简单http协议" class="headerlink" title="简单http协议"></a>简单http协议</h3><p>http不保存状态<br>持久链接节省流量：1.长连接（keep-alive）; 2.管线话（pipeline）<br>使用cookie的状态管理</p>
<h3 id="http报文内的http信息"><a href="#http报文内的http信息" class="headerlink" title="http报文内的http信息"></a>http报文内的http信息</h3><p>请求报文与响应报文结构<br><img src="media/15177516634047/15189246342719.jpg" alt=""></p>
<p>编码提升传输速率：<br>1.压缩；<br>2.分块<br>Content-Type：<br>Range:获取内容范围<br>内容协商返回最合适的内容</p>
<h3 id="返回结果状态码"><a href="#返回结果状态码" class="headerlink" title="返回结果状态码"></a>返回结果状态码</h3><p>2xx成功<br>3xx重定向<br>4xx客户端失败<br>5xx服务端失败</p>
<h3 id="与http协作的web服务器"><a href="#与http协作的web服务器" class="headerlink" title="与http协作的web服务器"></a>与http协作的web服务器</h3><p>通信数据转发程序：代理、网关、隧道<br>代理：<br><img src="media/15177516634047/15189386234933.jpg" alt=""></p>
<p>使用代理服务器的理由：<br>1.利用缓存减少网络流量<br>2.访问控制</p>
<p>代理的分类：缓存代理、透明代理</p>
<p>网关：网关与代理很像，而网关能使通信线路上的服务器提供非http协议服务</p>
<h3 id="http首部"><a href="#http首部" class="headerlink" title="http首部"></a>http首部</h3><p>首部字段格式：</p>
<blockquote>
<p>首部字段名称：字段值<br>4种首部字段类型：</p>
<ol>
<li>通用首部字段（General Header Fields）</li>
<li>请求首部字段</li>
<li>响应首部字段</li>
<li>实体首部字段</li>
</ol>
</blockquote>
<p>Cookie:Cookie的工作机制是<strong>用户识别</strong>与<strong>状态管理</strong>。<br>用户识别本身也算一种状态管理。</p>
<h3 id="确保web安全的https"><a href="#确保web安全的https" class="headerlink" title="确保web安全的https"></a>确保web安全的https</h3><p>http协议中有可能存在信息窃听与身份伪装等安全问题，使用https可以有效地防止这些问题。<br>http的缺点：</p>
<ul>
<li>使用明文通信，信息有可能被窃听</li>
<li>不验证通信方，有可能遭遇身份伪装</li>
<li>无法验证报文的完整性，有可能信息被篡改</li>
</ul>
<p><strong>http + 加密 + 认证 + 完整性保护 = https
</strong></p>
<p><img src="media/15177516634047/15189593763237.jpg" alt=""></p>
<h4 id="加密方式："><a href="#加密方式：" class="headerlink" title="加密方式："></a>加密方式：</h4><ol>
<li>对称密钥加密：只有一个密钥，加解密都使用同一个密钥</li>
<li>非对称密钥加密，包含公钥与私钥，公钥是公开的，任何都可以获取，用于加密，私钥用于解密</li>
</ol>
<p>https采用混合加密机制：</p>
<ol>
<li>使用非对称加密方式交换稍后在对称密钥加密要使用的私有密钥</li>
<li>在确保交换的私钥安全的前提下，使用对称密钥加密方式加密</li>
</ol>
<h4 id="证明公开密钥正确性的证书"><a href="#证明公开密钥正确性的证书" class="headerlink" title="证明公开密钥正确性的证书"></a>证明公开密钥正确性的证书</h4><p><em><strong>但是非对称密钥加密还是存在一些问题：无法证明公钥是货真价实的公钥</strong></em></p>
<p>为了解决上述问题，可以使用数字证书认证机构（CA，Certificate Authority）和其相关的机构颁发的公开密钥证书 </p>
<h4 id="https的安全通信机制"><a href="#https的安全通信机制" class="headerlink" title="https的安全通信机制"></a>https的安全通信机制</h4><ol>
<li>客户端发送Client hello 报文开始SSL通信，报文中包含支持的SSL版本、加密组件列表（所使用的加密算法级以及密钥长度）</li>
<li>服务端可以进行SSL通信时，会以Server Hello报文作为应答，报文中包含SSL版本、加密组件，加密组件是从接收到的客户端加密组件列表中筛选出来的。</li>
<li>之后服务端发送Certificate报文，包含公开密钥的证书</li>
<li>最后服务器发送Server Hello Done 报文通知客户端，最初阶段的SSL握手协商部分结束</li>
<li>SSL握手结束后，客户端以 Client Key Exchange 报文作为回应，该报文包含通信加密中被称为Pre-master secret 的随机密码串。该报文已使用步骤3中的公钥进行加密</li>
<li>接着客户端会继续发送 Change Cipher Spec 报文，提示服务端后续的通信将使用 Pre-master secret 密钥加密</li>
<li>客户端发送Finished。该报文包含链接至今全部报文的整体校验值。此次握手是否成功，以服务端是否能正确解密该报文为准。</li>
<li>服务端发送 Change Cipher Spec 报文</li>
<li>服务端发送 Finished 报文</li>
<li>服务端与客户端的Finished报文交换完毕后，SSL链接就算是建立完成。此处开始进行应用层通协议信，即发送Http响应</li>
<li>应用层协议通信</li>
<li>最后由客户端断开SSL链接。断开连接时，客户端发送close_notify报文。</li>
</ol>
<p>SSL速度慢：1、网络通信慢；2、大量消耗CPU及内存，导致处理速度慢</p>
<h3 id="确认访问用户身份的认证"><a href="#确认访问用户身份的认证" class="headerlink" title="确认访问用户身份的认证"></a>确认访问用户身份的认证</h3><h4 id="SSL客户端的认证步骤"><a href="#SSL客户端的认证步骤" class="headerlink" title="SSL客户端的认证步骤"></a>SSL客户端的认证步骤</h4><ol>
<li>服务器收到需要认证的资源请求，就会发送Certificate Request 报文，要求客户端提供客户端证书</li>
<li>客户端把客户端证书信息以Client Certificate报文的形式发送给服务端</li>
<li>服务端验证通过后，领取证书内的公开密钥，然后开始HTTPS通信</li>
</ol>
<h4 id="SSL客户端认证采用双因素认证"><a href="#SSL客户端认证采用双因素认证" class="headerlink" title="SSL客户端认证采用双因素认证"></a>SSL客户端认证采用双因素认证</h4><p>第一个认证因素的客户端证书，用来认证客户端计算机，另一个认证因素的密码则用来认证来自用户本人</p>
<h4 id="基于表单认证"><a href="#基于表单认证" class="headerlink" title="基于表单认证"></a>基于表单认证</h4><p>Session管理以及Cookie的应用<br>由于Http是无状态协议，已认证通过的用户状态无法在协议层面保存。即无法实现状态管理，于是可以使用Cookie来管理Session</p>
<p><img src="media/15177516634047/15190975324819.jpg" alt=""></p>
<h3 id="基于HTTP功能追加的协议"><a href="#基于HTTP功能追加的协议" class="headerlink" title="基于HTTP功能追加的协议"></a>基于HTTP功能追加的协议</h3><h4 id="消除瓶颈的SPDY协议"><a href="#消除瓶颈的SPDY协议" class="headerlink" title="消除瓶颈的SPDY协议"></a>消除瓶颈的SPDY协议</h4><p><img src="media/15177516634047/15191113047950.jpg" alt=""></p>
<p>SPDY功能：</p>
<ol>
<li>多路复用</li>
<li>赋予请求优先级</li>
<li>压缩HTTP首部</li>
<li>推送功能</li>
<li>服务器提示功能</li>
</ol>
<h4 id="全双工通信的WebSocket"><a href="#全双工通信的WebSocket" class="headerlink" title="全双工通信的WebSocket"></a>全双工通信的WebSocket</h4><p>WebSocket的主要特点：</p>
<ol>
<li>推送功能</li>
<li>减少通信量</li>
</ol>
<p>WebSocket握手过程<br><img src="media/15177516634047/15191121986953.jpg" alt=""></p>
<h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h4><p>改善用户使用Web是的速度体验</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Mochangxing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mochangxing</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.1.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
