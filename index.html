<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.1.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.1.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Mochangxing">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mochangxing">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mochangxing">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Mochangxing</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mochangxing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/27/iOS性能优化之帧率优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/27/iOS性能优化之帧率优化/" itemprop="url">
                  iOS性能优化之帧率优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-27T20:45:24+08:00">2018-08-27</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="影响帧率的原因"><a href="#影响帧率的原因" class="headerlink" title="影响帧率的原因"></a>影响帧率的原因</h3><h4 id="屏幕显示图像的原理："><a href="#屏幕显示图像的原理：" class="headerlink" title="屏幕显示图像的原理："></a><strong>屏幕显示图像的原理</strong>：</h4><p><img src="https://raw.githubusercontent.com/Mochangxing/blogImages/master/media/15352705850650/15352757694905.png" alt=""></p>
<p>一般而言，计算机系统中CPU、GPU以及显示器以以上这种方式协同工作。CPU计算好需要会显示的内容提交给GPU，GPU渲染完成后将渲染结果存入缓存区，随后视频控制器根据VSync信号，将缓冲区的内容显示到显示器上。</p>
<p>在这个过程中，<strong>CPU的主要职责是计算</strong>，<strong>GPU的主要职责是渲染</strong></p>
<h4 id="影响帧率的原因-1"><a href="#影响帧率的原因-1" class="headerlink" title="影响帧率的原因"></a><strong>影响帧率的原因</strong></h4><ul>
<li><p>CPU的资源消耗原因</p>
<ol>
<li><p>对象的创建</p>
<p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗资源。尽量用轻量级的对象代替重量对象，可以对内存有所优化。比如CALayer比UIView要轻量很多，因为不需要相应触摸事件。如果对象不涉及UI操作尽量放到后台线程去创建。，另外通过Storyboard创建视图对象时，要比直接通过代码创建对象消耗非常多的资源。</p>
</li>
</ol>
</li>
</ul>
<pre><code>2. 对象的调整

   对象的调整也是消耗CPU资源的原因之一。特别指出：CALayer内部并没有属性，当调用属性方法时，它内部是通过Runtime的resolveInstanceMethod为对象临时添加一个方法，并把对应属性值保存在内部的一个Dictionary中，同时还会通知delegate、创建动画等等，非常消耗资源，UIView关于显示相关属性的调整实际上都是对CALayer属性的调整。 

3. 对象的销毁

    对象销毁虽然对资源的消耗不多，但是积累起来也不容忽视。通常容器类持有大量对象时，其销毁时资源的消耗就非常明显。如果对象能放到后台释放，那就放到后台释放。为了避免编译器警告，把对象捕获到Block，再扔到后台队列随便发送个消息就OK。


    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SArray *tmp = self.array;</span><br><span class="line">self.array = nil;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [tmp class];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


4. 布局计算

    布局计算是App种最为常见的资源消耗的地方，如果能在后台提前计算好布局、并对布局进行缓存，那么就不会产生性能问题了。还有要尽量避免多次频繁的计算UIView.frame/bounds/center 等属性。因为调整这些属性非常消耗性能。

5. 文本计算

    如果一个页面中包含大量文本，文本的宽高会占用很大一部分资源。可以使用[NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。

6. 文本渲染

    常见的文本控件（UILabel、UITextView等）、其排版和绘制都是在主线程进行的，当文本数量很大时，CPU压力非常大。对此的解决方案是，自定义文本控件，用TextKit或者CoreText对文本异步绘制。可以参考YYTextKit。
7. 图片的解码

    UIImage或者CGImageSource创建的图片，并不会立刻解码。当图片设置到UIImageView或者CALayer.contents中，且CALayer被提交到CPU前，CGImage才会被解码，这一步发生在主线程。想要绕开这个机制，常见的做法是在后台线程将图片绘制到CGBitmapContext中，然后冲Bitmap中直接创建图片。目前常见的图片库都带有这个功能。    


8. 图像的绘制

    图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。大致过程如下：


    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)display &#123;</span><br><span class="line">    dispatch_async(backgroundQueue, ^&#123;</span><br><span class="line">         CGContextRef ctx = CGBitmapContextCreate(...);</span><br><span class="line">        // draw in context...</span><br><span class="line">         CGImageRef img = CGBitmapContextCreateImage(ctx);</span><br><span class="line">         CFRelease(ctx);</span><br><span class="line">         dispatch_async(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">         &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>GPU的资源消耗</p>
<ol>
<li><p>纹理的渲染</p>
<p> 所有的bitmap，包括图片、文本、栅格化的内容，最终都是有内存提交到显存，绑定为GPU Texture。不论是提交显存的过程，还是GPU调整和渲染Texture的过程都要消耗不少GPU资源。 短时间内显示大量图片时（比如UITableView 存在大量图片并快速滑动时），CPU占用了率很低，GPU却非常高，界面仍然会掉帧。针对这种情况只能将减少短时间显示大量图片，尽可能将多张图片合成一张进行显示。<br> 另外当图片过大，超过GPU的最大纹理尺寸时，需要先交由CPU进行预处理。这对CPU个GPU都会带来额外的消耗。</p>
</li>
</ol>
</li>
</ul>
<pre><code>2. 视图的混合

    当多个视图重叠在一起显示时，GPU首先会把它们混合到一起，再进行渲染。如果视图结构过于复杂，混合过程也会消耗很多GPU资源。最好的办法是，尽量减少视图层级和数量，并在不透明的视图里标明opaque属性以避免无用的Alpha通道合成


3. 图形的生成

    离屏渲染，CALayer的 border、圆角、阴影、遮罩，CASharpLayer的矢量图显示，通常会触发离屏渲染。而离屏渲染通常发生在GPU中。开启 CALayer.shouldRasterize属性会使视图渲染内容被缓存起来，下次绘制的时候可以直接显示缓存。而最彻底的解决办法是：把需要显示的图型在后台线程绘制为图片，避免使用圆角、阴影遮罩等属性。
</code></pre><h3 id="如何发现被定位卡顿问题"><a href="#如何发现被定位卡顿问题" class="headerlink" title="如何发现被定位卡顿问题"></a>如何发现被定位卡顿问题</h3><p>在了解了影响帧率的原因以及解决办法后，我们可以在开发过程中应该提高警惕，尽量避免写影响性能的代码。但是当我们接手一个新的业务模块时，应该如何发现卡顿问题并定位呢？</p>
<h4 id="卡顿检测工具"><a href="#卡顿检测工具" class="headerlink" title="卡顿检测工具"></a>卡顿检测工具</h4><p>目前业界比较通用的卡顿检测方案是：FPS检测 + 主线程RunLoop检测</p>
<p><img src="media/15352705850650/15352854818625.jpg" alt=""></p>
<p>其主要原理是，开辟一个子线程检测主线程RunLoop，检测kCFRunLoopBeforeSources与kCFRunLoopAfterWaiting这两个状态间的耗时，并综合FPS指标的来检测卡顿。</p>
<p>监听主线程RunLoop：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)start</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    // 创建信号 用于阻塞子线程</span><br><span class="line">    semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    </span><br><span class="line">    // 注册RunLoop状态观察</span><br><span class="line">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">    observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                       kCFRunLoopAllActivities,</span><br><span class="line">                                       YES,</span><br><span class="line">                                       0,</span><br><span class="line">                                       &amp;runLoopObserverCallBack,</span><br><span class="line">                                       &amp;context);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line"></span><br><span class="line">    // 开启子线程监控</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        while (YES)</span><br><span class="line">        &#123;</span><br><span class="line">            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 16*NSEC_PER_MSEC));</span><br><span class="line">            if (st != 0)</span><br><span class="line">            &#123;</span><br><span class="line">               //主线程超时，综合FPS判断是佛卡顿，并dump堆栈信息 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FPS 检测基于DisplayLink计算帧率。<br>卡顿堆栈信息获取，这里就不展开了，可以参考这篇文章<a href="https://blog.csdn.net/abc649395594/article/details/52350426" target="_blank" rel="noopener">获取任意线程调用栈的那些事</a>，分析的很详细</p>
<h3 id="买家版帧率优化实践"><a href="#买家版帧率优化实践" class="headerlink" title="买家版帧率优化实践"></a>买家版帧率优化实践</h3><p>买家版feed流中最为常见的卡片，包含了大量的图片以及文字，卡片视图数量很多，层级也很复杂。大量图片以及文本的绘制可以说是影响帧率的最大因素。因此初步的优化方案是，引入ASDisplayKit异步渲染框架，替换文本控件和图片控件。ASDisplayKit的核心思想是将所有能异步执行的操作如：文本和布局的计算、渲染、图片的解码、绘制等通通从主线程移到子线程。</p>
<p>在引入ASDisplayKit后，页面帧率有所提升，但卡顿情况仍较为严重。而页面的卡片类型多大七八种，而每个卡片的实现代码少则大大几百行，多则一千多行。如果单纯代码Review查找性能瓶颈的代码，是一件相当低效的事情，因此引入了卡顿检测工具。引入卡顿检测工具后，发现：虽然使用了FDTemplateLayoutCell缓存了Cell高度避免重复计算，但是卡片所有文本宽高计算，并且没有缓冲，每次视图进入屏幕时都需要重新计算，而文本宽高的计算恰恰又是影响性能重要原因之一。</p>
<p>AutoLayout也是影响性能的一个因素，买家版的卡片也大量使用了AutoLayout，如果将卡片的布局移到异步线程，那么性能还会有所提升。</p>
<p>综上，买家版的性能瓶颈主要在于：文本宽高的计算、大量文本的绘制、大量图片的解码绘制以及AutoLayout带来的性能影响。</p>
<p>卡顿检测发现的其他问题：1. 主线程读取缓存并反序列化；2. VDTrick 遍历UIController.view 的所有子view；3. 网络请求回调时，主线程进行耗时的卡片高度计算操作。3.API的使用不当</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/26/RAC rac_signalForSelector 如何实现对象方法的hook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/26/RAC rac_signalForSelector 如何实现对象方法的hook/" itemprop="url">
                  RAC rac_signalForSelector 如何实现对象方法的hook
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-26T00:45:24+08:00">2018-08-26</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RAC-rac-signalForSelector-如何实现对象方法的hook"><a href="#RAC-rac-signalForSelector-如何实现对象方法的hook" class="headerlink" title="RAC rac_signalForSelector 如何实现对象方法的hook"></a>RAC rac_signalForSelector 如何实现对象方法的hook</h1><h2 id="重温Objective-C的消息机制"><a href="#重温Objective-C的消息机制" class="headerlink" title="重温Objective-C的消息机制"></a>重温Objective-C的消息机制</h2><p>消息转发机制：</p>
<ol>
<li>首先在该类的缓存方法列表cache_method_list中查找，是否存在相关方法</li>
<li>上一步中若没有命中，则从方法列表 objc_method_list中查找</li>
<li>上一步中若没有命中，则从父类super的方法列表 objc_method_list中查找，直至根类NSObject</li>
<li>上一步中若没有命中，则进入消息转发流程，一共分为三步：类的动态方法解析、备用接收者对象、完整消息转发</li>
<li>动态方法解析：也就是 <code>+(BOOL)resolveClassMethod:</code>方法或<code>+(BOOL)resolveInstanceMethod:(SEL)sel</code>方法。该方法允许向当前对象添加方法实现。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+(BOOL)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    if(aSEL == @selector(doFoo:))</span><br><span class="line">    &#123;</span><br><span class="line">            class_addMethod([self class],aSEL,(IMP)fooMethod,&quot;v@:&quot;);</span><br><span class="line">            return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>备用接收者对象：<code>– (id)forwardingTargetForSelector:(SEL)aSelector</code> 方法，<br>该方法提供一次机会引导Objective-C RunTime 到备用接收者对象上。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    if(aSelector == @selector(doFoo:))&#123;</span><br><span class="line">        return alternateObject;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>完整消息转发：<code>– (void)forwardInvocation:(NSInvocation *)anInvocation</code>方法，<code>NSInvocation</code> 是Objective-C 消息的对象形式，它包含了消息的所有信息，这也就意味着，一旦有了<code>NSInvocation</code> 对象，你就可以改变这个消息的所有信息，包括目标对象、selector以及参数。例如可以这样做（当然RAC与Aspect所做的事情远远不止这么简单啦）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(void)forwardInvocation:(NSInvocation *)invocation</span><br><span class="line">&#123;  </span><br><span class="line">    SEL invSEL = invocation.selector;    </span><br><span class="line">    if([altObject respondsToSelector:invSEL]) &#123;        </span><br><span class="line">        [invocation invokeWithTarget:altObject];    </span><br><span class="line">    &#125; else &#123;        </span><br><span class="line">        [self doesNotRecognizeSelector:invSEL];    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rac-signalForSelector-源码走读"><a href="#rac-signalForSelector-源码走读" class="headerlink" title="rac_signalForSelector 源码走读"></a>rac_signalForSelector 源码走读</h2><p><code>- (RACSignal *)rac_signalForSelector:(SEL)selector</code>方法位于NSObject+RACSelectorSignal 这个category下。先来看一下.h 头文件。头文件只对外暴露了以下两个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)rac_signalForSelector:(SEL)selector;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (RACSignal *)rac_signalForSelector:(SEL)selector fromProtocol:(Protocol *)protocol;</span><br></pre></td></tr></table></figure>
<p>再来看一下.m 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal *)rac_signalForSelector:(SEL)selector &#123;</span><br><span class="line">	NSCParameterAssert(selector != NULL);</span><br><span class="line"></span><br><span class="line">	return NSObjectRACSignalForSelector(self, selector, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSignal *)rac_signalForSelector:(SEL)selector fromProtocol:(Protocol *)protocol &#123;</span><br><span class="line">	NSCParameterAssert(selector != NULL);</span><br><span class="line">	NSCParameterAssert(protocol != NULL);</span><br><span class="line"></span><br><span class="line">	return NSObjectRACSignalForSelector(self, selector, protocol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两方法最终都调用了C函数<code>NSObjectRACSignalForSelector</code>。</p>
<ol>
<li>获取Selector的别名<code>aliasSelector</code></li>
<li>是否存在关联对象，有则跳至步骤8</li>
<li>替换类<code>RACSwizzleClass(self)</code></li>
<li>获取替换的类，这一步主要是替换了原类中<code>forwardInvocation:</code>的实现。</li>
<li>创建RACSubject对象，并设置关联对象</li>
<li>获取原方法<code>class_getInstanceMethod(class, selector);</code></li>
<li>若原方法不存在，则向该类添加方法 <code>class_addMethod(class, selector, _objc_msgForward, typeEncoding)</code>。值得注意的是，方法体为<code>_objc_msgForward</code>，即上一节中提到的完整消息转发方法的方法体。</li>
<li>若原方法存在，则向该类添加<code>aliasSelector</code>，其实现即为原方法的实现，并将原方法的实现替换为<code>_objc_msgForward</code></li>
<li>返回RACSubject对象</li>
</ol>
<p>到此为止，rac_signalForSelector 的全部工作便是将目标<code>selector</code>的实现替换成了消息转发。</p>
<p>接下来，看看消息转发的实现部分，也就是步骤2中的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void RACSwizzleForwardInvocation(Class class) &#123;</span><br><span class="line">	SEL forwardInvocationSEL = @selector(forwardInvocation:);</span><br><span class="line">	Method forwardInvocationMethod = class_getInstanceMethod(class, forwardInvocationSEL);</span><br><span class="line"></span><br><span class="line">	// Preserve any existing implementation of -forwardInvocation:.</span><br><span class="line">	void (*originalForwardInvocation)(id, SEL, NSInvocation *) = NULL;</span><br><span class="line">	if (forwardInvocationMethod != NULL) &#123;</span><br><span class="line">		originalForwardInvocation = (__typeof__(originalForwardInvocation))method_getImplementation(forwardInvocationMethod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	id newForwardInvocation = ^(id self, NSInvocation *invocation) &#123;</span><br><span class="line">		BOOL matched = RACForwardInvocation(self, invocation);</span><br><span class="line">		if (matched) return;</span><br><span class="line"></span><br><span class="line">		if (originalForwardInvocation == NULL) &#123;</span><br><span class="line">			[self doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			originalForwardInvocation(self, forwardInvocationSEL, invocation);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	class_replaceMethod(class, forwardInvocationSEL, imp_implementationWithBlock(newForwardInvocation), &quot;v@:@&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码很简单，就是hook了<code>forwardInvocation:</code>方法，当触发完整消息转发时，首先交由<code>RACForwardInvocation</code>响应，若<code>RACForwardInvocation</code>响应了则结束消息转发，否则走原消息转发流程。</p>
<p>接下来看看<code>RACForwardInvocation</code>的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static BOOL RACForwardInvocation(id self, NSInvocation *invocation) &#123;</span><br><span class="line">	SEL aliasSelector = RACAliasForSelector(invocation.selector);</span><br><span class="line">	RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);</span><br><span class="line"></span><br><span class="line">	Class class = object_getClass(invocation.target);</span><br><span class="line">	BOOL respondsToAlias = [class instancesRespondToSelector:aliasSelector];</span><br><span class="line">	if (respondsToAlias) &#123;</span><br><span class="line">		invocation.selector = aliasSelector;</span><br><span class="line">		[invocation invoke];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (subject == nil) return respondsToAlias;</span><br><span class="line"></span><br><span class="line">	[subject sendNext:invocation.rac_argumentsTuple];</span><br><span class="line">	return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获取<code>selector</code>的别名 <code>aliasSelector</code></li>
<li>获取关联对象<code>subject</code></li>
<li>执行 <code>aliasSelector</code>，并通过<code>subject</code>将返回值以RACTuple的形式发送出去。</li>
</ol>
<p>总结一下RAC实现原理：RAC利用RunTime机制将所要监听的方法，全部转发到<code>forwardInvocation:</code>，并像<code>class</code>添加了别名方法<code>aliasSelector</code>，其方法体即原方法的方法体。那么当外部调用原方法时，就会触发消息转发流程。而RAC拦截了<code>forwardInvocation:</code>，并执行别名方法<code>aliasSelector</code>，最后将返回结果发送出去。</p>
<p>RAC在实现过程中，对Runtime的使用相当的深入。针对各种情况的考虑也是相当的周全，其实现也相当严谨，特别值得学习。</p>
<h3 id="深度改造Runtime的弊端"><a href="#深度改造Runtime的弊端" class="headerlink" title="深度改造Runtime的弊端"></a>深度改造Runtime的弊端</h3><p>RAC 通过深度改造对象的消息机制以达到AOP的目的，对于日常开发来说相当便利。不过值得注意的是：<strong>当一个项目内存在多个库深度改造对象的消息机制，就会产生不可避免的冲突</strong>，比如<code>ASpect</code>这个库，它的实现原理有RAC完全一样，应该都是借鉴了KVO的实现方式，唯一的不同点在于<code>ASpect</code>的消息<code>forwardInvocation:</code>实现比RAC稍微多了一步：当对象无法响应selector时，会调用 <code>doesNotRecognizeSelector:</code> 抛出异常。</p>
<p><strong>若同时使用这两个库对同一对象的同一方法Hook，那么该方法将无法被执行，并存在Crash隐患。</strong></p>
<p>经过以上的研究，对Runtime有了更深入的了解。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/iOS性能优化之启动优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/iOS性能优化之启动优化/" itemprop="url">
                  iOS性能优化之启动优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-20T10:45:24+08:00">2018-08-20</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这一篇写一写关于iOS的启动，都是前人的文章，自己实践记录一下，加深理解和认识，文末附上参考链接。</p>
<h3 id="App启动流程"><a href="#App启动流程" class="headerlink" title="App启动流程"></a>App启动流程</h3><p>main() 函数作为一个应用程序的入口，从App的icon 被点击，到程序进入main函数这段时间内，系统已经完成了很多工作。iOS的启动过程大致可分为两部分：pre-main time ,post-main time<br><img src="https://raw.githubusercontent.com/Mochangxing/blogImages/master/media/15354675150632/15355095088116.jpg" alt=""></p>
<h4 id="Pre-main-time"><a href="#Pre-main-time" class="headerlink" title="Pre-main time"></a>Pre-main time</h4><p>下图是Apple在WWDC上展示pre-main 阶段的流程图。</p>
<p><img src="https://raw.githubusercontent.com/Mochangxing/blogImages/master/media/15354675150632/15355540940666.jpg" alt=""></p>
<ol>
<li><p>Load dylibs</p>
<p>加载动态库，系统首先会可执行文件，然后加载动态链接库dyld，dyld是一个用来专门加载动态链接库的库（😂）。加载完dyld，dyld从可执行文件的依赖开始，递归的加载所有依赖的动态链接库。</p>
</li>
<li><p>Rebase &amp; Bind</p>
<p>由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这两步来修正。Rebase就是用来修正动态库内部指针的指向。而动态库之间存在依赖关系，在刚加载完所有动态库后，它们之间还是相互独立的状态。Bind就是将动态库内部符号表指向与所依赖的动态库的资源</p>
</li>
<li><p>Objc</p>
<p>这一步开始进入Objc阶段，启动Runtime。这一步的主要工作有：注册Objc类，把category的定义插入方法列表，确保每一个selector的唯一</p>
</li>
<li><p>Initializers</p>
<p>这一步的工作主要有：Objc的+load()函数、C++的构造函数属性函数 形如attribute((constructor)) void DoSomeInitializationWork()、非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度     </p>
</li>
</ol>
<ul>
<li>动态库的load方法早于主二进制的所有load方法被调用</li>
</ul>
<h4 id="post-main-time"><a href="#post-main-time" class="headerlink" title="post-main time"></a>post-main time</h4><p>post-main time的统计口径：从进入main函数开始，到willFinishLaunch结束。大多数App都会在这个阶段完成相关SDK的初始化工作。</p>
<h3 id="如何精确测量App启动速度"><a href="#如何精确测量App启动速度" class="headerlink" title="如何精确测量App启动速度"></a>如何精确测量App启动速度</h3><h4 id="Xcode-测量-pre-main-耗时"><a href="#Xcode-测量-pre-main-耗时" class="headerlink" title="Xcode 测量 pre-main 耗时"></a>Xcode 测量 pre-main 耗时</h4><p>Xcode 提供了一个很赞的方法，只需要在 Edit scheme -&gt; Run -&gt; Arguments 中将环境变量 DYLD_PRINT_STATISTICS 设为 1，就可以看到 main 之前各个阶段的时间消耗。</p>
<pre><code>Total pre-main time: 2.1 seconds (100.0%)
         dylib loading time: 106.81 milliseconds (4.9%)
        rebase/binding time: 192.29 milliseconds (8.9%)
            ObjC setup time: 855.42 milliseconds (39.7%)
           initializer time: 995.53 milliseconds (46.2%)
           slowest intializers :
             libSystem.B.dylib :  29.33 milliseconds (1.3%)
    libMainThreadChecker.dylib : 101.49 milliseconds (4.7%)
          libglInterpose.dylib : 297.92 milliseconds (13.8%)
         libMTLInterpose.dylib :  60.73 milliseconds (2.8%)
                       ModelIO :  69.89 milliseconds (3.2%)
              MediaLibraryCore :  44.31 milliseconds (2.0%)
                   WDBuyerUniv : 363.40 milliseconds (16.9%)

</code></pre><p>以上为买家版的pre-main阶段的详细耗时，可以看到大头是在ObjC setup和initializer阶段</p>
<h4 id="如何统计线上-pre-main-时间"><a href="#如何统计线上-pre-main-时间" class="headerlink" title="如何统计线上 pre-main 时间"></a>如何统计线上 pre-main 时间</h4><h5 id="统计全部load方法的耗时"><a href="#统计全部load方法的耗时" class="headerlink" title="统计全部load方法的耗时"></a>统计全部load方法的耗时</h5><p>dyld会优先初始化动态库，然后初始化App的可执行文件。只要在最早加载的动态库中Hook App中全部的load函数，然后打点统计就可以了。那么问题就变成了如何找到最早加载的动态库？</p>
<p>动态库的 load 顺序是与 Load Commands 顺序和依赖关系息息相关的。如图所示：</p>
<p><img src="https://raw.githubusercontent.com/Mochangxing/blogImages/master/media/15354675150632/15357240745282.jpg" alt=""></p>
<h5 id="如何调整Load-Command-顺序-让自定义的动态库率先被加载"><a href="#如何调整Load-Command-顺序-让自定义的动态库率先被加载" class="headerlink" title="如何调整Load Command 顺序, 让自定义的动态库率先被加载?"></a>如何调整Load Command 顺序, 让自定义的动态库率先被加载?</h5><p>思路1：Mach-O 本质是还是一个文件，想要让上图中的AAAAAHookLoad被第一个加载，那么只要把Load Command 与第一个动态库的Load Command 替换即可。该方案需要对Mach-O的文件格式有足够的了解</p>
<p>思路2：编译过程，指定Load Command的顺序。按理说，Mach-O中Load Command的顺序应该是按照一定的规则写入的。只要能找到修改响应规则的方法，应该比思路1容易得多。目前还没找到（😂）</p>
<p>自定义动态库，已Embed framework的方式加入App工程 -&gt; 自定义的某个class load 方法中 hook 全部类的load方法 -&gt; hook方法中统计load方法耗时 -&gt; 输出</p>
<p><strong>注意事项：</strong></p>
<p><strong>1. 不能为了统计性能，自己却造成了性能问题，获取所有的类并且 Hook load 函数还是比较耗时的，控制不好反而增加了启动时间</strong></p>
<p><strong>2. 不当某个class 与其 category 同时实现了 load方法时，只能hook category 中的方法，需要考虑如何同时hook。</strong></p>
<h5 id="度量-C-Static-Initializers"><a href="#度量-C-Static-Initializers" class="headerlink" title="度量 C++ Static Initializers"></a>度量 C++ Static Initializers</h5><p>Runtime 会从 mod_init_func 这个 section 中读取所有的函数指针，然后执行函数调用，这些函数指针对应的正是 C++ Static Initializers 和 <strong>attribute</strong>((constructor))修饰的函数。</p>
<p>因为它们的执行顺序在 load 函数之后，所以可以在 load 函数中把 mod_init_func 中的地址都替换成我们的 hook 函数指针，然后再把原函数指针保存到一个全局数据中，当执行我们的 hook 函数时，从全局数组中取出原函数地址执行。</p>
<p>在这里张贴下主要代码，更多可以参考这个链接：<a href="https://github.com/everettjf/Yolo/blob/master/HookCppInitilizers/hook_cpp_init.mm" target="_blank" rel="noopener">https://github.com/everettjf/Yolo/blob/master/HookCppInitilizers/hook_cpp_init.mm</a></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="pre-main-阶段优化"><a href="#pre-main-阶段优化" class="headerlink" title="pre-main 阶段优化"></a>pre-main 阶段优化</h4><ol>
<li><p>Load dylibs 阶段</p>
<ul>
<li>这一阶段，优化点主要在减少不必要的动态库，因为动态链接比较耗时，</li>
<li>另外一点就是，尽可能把多个动态库合并成一个。系统的动态库有共享缓存等优化方案，但是我们的动态库变多了的话会非常耗时，所以合并动态库是一个有效且可行的方案</li>
<li>也可以尝试对一些非启动阶段所必须的动态库，延时加载（仅想法，未验证）。</li>
</ul>
</li>
<li><p>Rebase &amp; Bind     </p>
<ul>
<li>对于Objc，减少class，selector和category这些元数据的数量。</li>
<li>对于C++，减少虚方法，因为虚方法会创建vtable。</li>
</ul>
</li>
<li><p>Initializers</p>
<ul>
<li>减少load方法的耗时，尽量将load方法的工作移到initialize。</li>
<li>不要使用 <strong>atribute</strong>((constructor)) 将方法显式标记为初始化器，而是让初始化方法调用时才执行。比如使用 dispatch_once(),pthread_once() 或 std::once()。也就是在第一次使用时才初始化，推迟了一部分工作耗时。</li>
</ul>
</li>
</ol>
<h4 id="main-阶段优化"><a href="#main-阶段优化" class="headerlink" title="main 阶段优化"></a>main 阶段优化</h4><p>启动任务分层，不需要及时初始化，不需要在主线程初始化的，都选择异步延时加载。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.jianshu.com/p/c14987eee107" target="_blank" rel="noopener">如何精确度量 iOS App 的启动时间</a></p>
<p><a href="http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/" target="_blank" rel="noopener">优化 App 的启动时间</a></p>
<p><a href="https://techblog.toutiao.com/2017/01/17/iosspeed/" target="_blank" rel="noopener">今日头条iOS客户端启动速度优化</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/11/AVPlayer缓存的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/11/AVPlayer缓存的实现/" itemprop="url">
                  AVPlayer 视频缓存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-11T23:01:01+08:00">2018-08-11</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="AVPlayer-视频缓存"><a href="#AVPlayer-视频缓存" class="headerlink" title="AVPlayer 视频缓存"></a>AVPlayer 视频缓存</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>目前买家版发布视频动态以及自动播放功能已经上线，视频白名单也已经全量开发。如果直接使用URL通过AVPlayer播放，系统并不会进行缓存，每次播放都必须重新下载。对于用户而言，流量是极大的消耗，播放体验也不够友好。</p>
<h3 id="AVAssetResourceLoaderDelegate"><a href="#AVAssetResourceLoaderDelegate" class="headerlink" title="AVAssetResourceLoaderDelegate"></a>AVAssetResourceLoaderDelegate</h3><p><code>AVAssetResourceLoaderDelegate</code>：专门用来处理AVAsset资源加载的协议。<br>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVURLAsset *urlAsset = ...</span><br><span class="line">[urlAsset.resourceLoader setDelegate:&lt;AVAssetResourceLoaderDelegate&gt; queue:dispatch_get_main_queue()];</span><br></pre></td></tr></table></figure>
<p>设置了<code>resourceLoader</code>的<code>delegate</code> 后，AVPlayer将把视频资源的下载工作交给<code>AVAssetResourceLoaderDelegate</code>来完成。</p>
<p><code>AVAssetResourceLoaderDelegate</code> 主要有以下两个方法，分别会在资源开始下载以及取消时被执行：</p>
<p>是否拦截资源下载请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest;</span><br></pre></td></tr></table></figure>
<p>取消请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader didCancelLoadingRequest:(AVAssetResourceLoadingRequest *)loadingRequest</span><br></pre></td></tr></table></figure>
<h3 id="AVAssetResourceLoadingRequest-分析"><a href="#AVAssetResourceLoadingRequest-分析" class="headerlink" title="AVAssetResourceLoadingRequest 分析"></a>AVAssetResourceLoadingRequest 分析</h3><p><code>AVAssetResourceLoadingRequest</code>携带了AVPlayer的请求信息，主要有以下几个属性：</p>
<ul>
<li><p><code>NSURLRequest *request</code>： 视频的URL相关信息</p>
</li>
<li><p><code>AVAssetResourceLoadingContentInformationRequest *contentInformationRequest</code>： 视频文件的信息请求，主要是为了获取视频类型、视频大小等相关信息，该请求会在视频第一个<code>AVAssetResourceLoadingRequest</code>中携带。</p>
</li>
<li><code>AVAssetResourceLoadingDataRequest *dataRequest</code>： 视频数据请求，指定了视频请求的数据范围，每次请求完成后，都要通过<code>dataRequest</code>将<code>response</code>塞给AVPlayer</li>
</ul>
<h3 id="AVAssetResourceLoaderDelegate-实现视频请求流程图"><a href="#AVAssetResourceLoaderDelegate-实现视频请求流程图" class="headerlink" title="AVAssetResourceLoaderDelegate 实现视频请求流程图"></a><code>AVAssetResourceLoaderDelegate</code> 实现视频请求流程图</h3><p><img src="https://github.com/Mochangxing/blogImages/blob/master/media/15330529045080/15339804735570.jpg?raw=true" alt=""></p>
<h3 id="如何实现视频缓存"><a href="#如何实现视频缓存" class="headerlink" title="如何实现视频缓存"></a>如何实现视频缓存</h3><p><code>AVAssetResourceLoadingRequest</code>视频请求实际上就是Http文件下载过程，需要通过<code>URLSession</code>创建一个<code>DataTask</code>请求数据。通过以上的分析，我们知道视频下载是一个分片下载的过程，因此视频缓存也应该是基于分片的缓存。而因为有了缓存的存在，当<code>AVPlayer</code>发起一个<code>AVAssetResourceLoadingRequest</code>请求了，就有可能一部分数据命中缓存，而一部分则没有。这时候我们就需要就<code>AVAssetResourceLoadingRequest</code>请求拆分成本地请求与远端请求了，拆分请求需要根据已缓存的数据来进行，因此需要一个缓存配置模块来存储，已缓存视频的信息。如下图所示：</p>
<p><img src="https://github.com/Mochangxing/blogImages/blob/master/media/15330529045080/15339964925158.jpg?raw=true" alt=""></p>
<h4 id="内存缓存还是磁盘缓存？"><a href="#内存缓存还是磁盘缓存？" class="headerlink" title="内存缓存还是磁盘缓存？"></a>内存缓存还是磁盘缓存？</h4><p>视频文件一般都比较大，如果采用内存缓存会对内存造成很大的压力，因此采用磁盘缓存，虽然磁盘缓存的读取速度要比内存慢，但对于视频来说其实可以忽略不计了。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>同一个url的视频缓存在同一个文件中，为了避免多线程同步的问题，因此同一时间同一个视频url不能存在多个下载请求</p>
<h4 id="整体架构设计"><a href="#整体架构设计" class="headerlink" title="整体架构设计"></a>整体架构设计</h4><p><img src="https://github.com/Mochangxing/blogImages/blob/master/media/15330529045080/15339980448809.jpg?raw=true" alt=""></p>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>既然是缓存，那么缓存策略就是必不可少的了。这里视频缓存参考了SDWebImage的缓存方案，采用了LRU缓存。主要通过过期时间与最大缓存空间两个维度来清理缓存。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/02/iOS性能监控/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/iOS性能监控/" itemprop="url">
                  iOS性能监控
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-02T22:32:01+08:00">2018-07-02</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS性能监控"><a href="#iOS性能监控" class="headerlink" title="iOS性能监控"></a>iOS性能监控</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>移动互联网的增长红利已经结束，如何运营好存量用户也变得越来越重要。而随着随着移动互联网的不断发展，用户也越来越关心应用的体验。随着业务不断快速迭代，复杂度不断增加，应用的性能问题势必会随之积累。而在传统的开发流程中，通常需要：线上用户反馈 -&gt; 分析问题原因 -&gt; 解决性能问题 -&gt; 验证等4步。我们必须思考，如何快速发现并解决日渐复杂的业务导致的功能不断迭代所产生的性能问题。近两年，APM技术快速发展，国内厂商更是百花齐放。最近对APM技术做了一个调研，希望以此文章作为一个总结，以加深认识。</p>
<h3 id="APM"><a href="#APM" class="headerlink" title="APM"></a>APM</h3><p>AMP即 Application Performance Manager，定位于帮助开发团队快速精确地定位性能问题，进而推动应用的性能和用户体验的提升。那么APM关心的性能指标都有哪些呢？如下所示：</p>
<ul>
<li>界面卡顿、卡顿堆栈</li>
<li>网络请求：成功率、状态码、流量、网络响应时间、HTTP与HTTPS的 DNS 解析、TCP握手、SSL握手（HTTP除外）、首包时间等时间</li>
<li>交互监控：页面加载时间</li>
<li>启动时间</li>
<li>崩溃率、崩溃堆栈</li>
<li>Abort 率：也就是由于内存过高的等原因，被系统杀死的情况</li>
<li>其他：内存、帧率、CPU使用率、启动时间、电量等</li>
</ul>
<p>性能指标如何采集？数据的采集最好尽量避免侵入业务代码，业务无感知的情况下完成采集工作，所以做好的方式是面向切面编程。<br>有了性能日志后，还需要对数据进行分析并定位问题。<br>整体APM流程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Mochangxing/blogImages/master/media/15299157861354/15305507247739.jpg" alt=""></p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="卡顿监控方案："><a href="#卡顿监控方案：" class="headerlink" title="卡顿监控方案："></a>卡顿监控方案：</h4><ol>
<li><p>FPS监控：通过监控一段连续的FPS计算丢帧率来衡量页面流畅性。</p>
</li>
<li><p>主线程监控：开辟一个子线程检测主线程RunLoop，当kCFRunLoopBeforeSources与kCFRunLoopAfterWaiting这两个状态间的耗时超过阈值时，就记为一次卡顿</p>
</li>
<li><p>综合监控：由于FPS与主线程卡顿监控容易发生抖动，业界又提出了一种综合方案，结合主线程监控、FPS监控、以及CPU等，作为卡顿的综合判断标准。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Mochangxing/blogImages/master/media/15299157861354/15299397869592.jpg" alt=""></p>
<p>卡顿日志采集上报： 参考PLcrashreporter，构造crash.log日志上报，结合符号表文件进行符号化</p>
<h4 id="网络监控"><a href="#网络监控" class="headerlink" title="网络监控"></a>网络监控</h4><p>方案1：继承NSURLProtocol 拦截Http请求</p>
<p>方案2：方法替换，动态代理，针对NSURLSession、NSURLConnection</p>
<p>方案3：使用fishhook库hook CFNetwork</p>
<p><img src="https://raw.githubusercontent.com/Mochangxing/blogImages/master/media/15299157861354/15300117877345.jpg" alt=""></p>
<h4 id="冷启动时间"><a href="#冷启动时间" class="headerlink" title="冷启动时间"></a>冷启动时间</h4><p><img src="https://raw.githubusercontent.com/Mochangxing/blogImages/master/media/15299157861354/15300128667611.jpg" alt=""></p>
<p>t(App 总启动时间) = t1(main()之前的加载时间) + t2(main()之后的加载时间)。</p>
<p>t1 = 系统的 dylib (动态链接库)和 App 可执行文件的加载时间</p>
<p>下面的步骤构成了 t1 的时间线：</p>
<p>Load dylibs -&gt; Rebase -&gt; Bind -&gt; ObjC -&gt; Initializers</p>
<p>t1比较难统计，目前业界的方案是在+load方法中打点统计，也就是上文时间线的Objc setUp阶段开始统计，但是这种方式是不够精确的。而且t1的大头其实是在Load dylibs阶段。目前只能通过xcode配置，在控制台打印的方式来统计。 </p>
<p>t2 = main函数执行之后到 AppDelegate 类中的applicationDidFinishLaunching:withOptions:方法执行结束前这段时间</p>
<h4 id="页面响应时间"><a href="#页面响应时间" class="headerlink" title="页面响应时间"></a>页面响应时间</h4><p>hook ViewController的生命周期</p>
<h4 id="崩溃率"><a href="#崩溃率" class="headerlink" title="崩溃率"></a>崩溃率</h4><h4 id="Abort率"><a href="#Abort率" class="headerlink" title="Abort率"></a>Abort率</h4><p>目前对于内存过高被杀死的情况是没有办法直接统计的，一般通过排除法来做百分比的统计，原理如下</p>
<ul>
<li>程序启动，设置标志位</li>
<li>程序正常退出，清楚标志</li>
<li>程序Crash，清楚标志</li>
<li>程序电量过低导致关机，这个也没办法直接监控，可以加入电量检测来辅助判断</li>
<li>第二次启动，标志位如果存在，则代表Abort一次，上传后台做统计</li>
</ul>
<h4 id="其他性能数据监控：FPS、CPU使用率、内存占用"><a href="#其他性能数据监控：FPS、CPU使用率、内存占用" class="headerlink" title="其他性能数据监控：FPS、CPU使用率、内存占用"></a>其他性能数据监控：FPS、CPU使用率、内存占用</h4>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/20/谈谈ReactiveCocoa-背后的响应式编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/20/谈谈ReactiveCocoa-背后的响应式编程/" itemprop="url">
                  谈谈ReactiveCocoa 函数响应式框架
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-20T00:45:24+08:00">2018-04-20</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>提纲：</p>
<h2 id="什么是纯函数（Pure-Function）"><a href="#什么是纯函数（Pure-Function）" class="headerlink" title="什么是纯函数（Pure Function）"></a>什么是纯函数（Pure Function）</h2><p><em>副作用</em>指的是，函数的行为受系统的全局状态所影响</p>
<h2 id="为什么要有纯函数"><a href="#为什么要有纯函数" class="headerlink" title="为什么要有纯函数"></a>为什么要有纯函数</h2><h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><h2 id="什么是副作用（Side-Effect），副作用能做什么。"><a href="#什么是副作用（Side-Effect），副作用能做什么。" class="headerlink" title="什么是副作用（Side Effect），副作用能做什么。"></a>什么是副作用（Side Effect），副作用能做什么。</h2><h2 id="什么是函数响应式编程"><a href="#什么是函数响应式编程" class="headerlink" title="什么是函数响应式编程"></a>什么是函数响应式编程</h2><h2 id="什么Monad以及为什么要引入Monad"><a href="#什么Monad以及为什么要引入Monad" class="headerlink" title="什么Monad以及为什么要引入Monad"></a>什么Monad以及为什么要引入Monad</h2><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><h2 id="ReactiveCocoa是如何实现响应式编程的"><a href="#ReactiveCocoa是如何实现响应式编程的" class="headerlink" title="ReactiveCocoa是如何实现响应式编程的"></a>ReactiveCocoa是如何实现响应式编程的</h2><h3 id="ReactiveCocoa-bind的实现"><a href="#ReactiveCocoa-bind的实现" class="headerlink" title="ReactiveCocoa bind的实现"></a>ReactiveCocoa bind的实现</h3><h3 id="ReactiveCocoa-return的实现"><a href="#ReactiveCocoa-return的实现" class="headerlink" title="ReactiveCocoa return的实现"></a>ReactiveCocoa return的实现</h3><h3 id="ReactiveCocoa封装的一系列操作符"><a href="#ReactiveCocoa封装的一系列操作符" class="headerlink" title="ReactiveCocoa封装的一系列操作符"></a>ReactiveCocoa封装的一系列操作符</h3><p>Functor:任何类别只要能执行<code>fmap</code>操作，就是一个<code>Functor</code><br><code>fmap</code>就是把一个函数应用在一个盒子里的值上，然后返回一个封装在盒子里的新值；</p>
<p>对于空值也就是<code>Nothing</code>来说，执行<code>fmap</code>操作后返回的还是<code>Nothing</code></p>
<p>对于<code>List</code>而言，执行<code>fmap</code>，会将函数应用在<code>List</code>的每一个值都上，并返回一个新的<code>List</code></p>
<p>总结一下：Functor是能将函数应用在值上的一种类型。换句话说，Functor就是支持将一个值映射成另一个新值的类型</p>
<p>那如果要将一个函数应用在另一个函数上呢？</p>
<p>也就是说一个函数执行了<code>fmap</code>操作后可以映射成一个新的函数，因此说函数也是<code>Functor</code><br>函数的<code>fmap</code> 操作就是函数的复合</p>
<p>Functor:<br>将一个普通函数应用到被封装的值上</p>
<p>Applicative：<br>将一个封装的函数应用在封装的值上</p>
<p>Monad：<br>将一个“<strong>接收一个普通值并返回一个被封装的值</strong>”的函数应用在一个被封装的值上，这一任务由函数 <code>&gt;&gt;=</code>(读作“bind”)完成。</p>
<h2 id="ReactiveCocoa是如何实现Monad的"><a href="#ReactiveCocoa是如何实现Monad的" class="headerlink" title="ReactiveCocoa是如何实现Monad的"></a>ReactiveCocoa是如何实现Monad的</h2><p>RACStream被定义为一种Monad类型，定义了两个基本操作<code>bind</code>个<code>return</code></p>
<p><code>RACStreamBindBlock</code>可以看做是“<strong>接收一个普通值并返回一个被封装的值</strong>”函数</p>
<h2 id="IO操作："><a href="#IO操作：" class="headerlink" title="IO操作："></a>IO操作：</h2>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/17/ReactCocoa-内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/17/ReactCocoa-内存管理/" itemprop="url">
                  ReactiveCoCoa 内存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-17T22:47:06+08:00">2018-04-17</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ReactiveCoCoa的内存管理相当的复杂，不过这导致的最终结果是：<strong>你可以不通过持有信号来处理他们</strong></p>
<p>如果ReactiveCoCoa框架要求你持有每一个信号，它使用起来将会很笨重，对于像网络请求等这些在未来使用的一次性信号来说，更是如此。你必须将长期存在的信号保存在属性中，当你完成相关操作后，还要确保将其清除，这很没意思。</p>
<h3 id="订阅者（Subscribers）"><a href="#订阅者（Subscribers）" class="headerlink" title="订阅者（Subscribers）"></a>订阅者（Subscribers）</h3><p>在进一步讨论之前，需要注意的是：<code>subscribeNext:error:completed:</code>（及其变体）会在<code>block</code>内隐式创建订阅者。因此在block中持有的任何对象，都会被订阅者持有。就像其他任何对象一样，self如果没有直接或间接引用它，它们 将不会被保留。</p>
<h3 id="有限或者短期的信号（Finite-Or-Short-Lived-Signals）"><a href="#有限或者短期的信号（Finite-Or-Short-Lived-Signals）" class="headerlink" title="有限或者短期的信号（Finite Or Short-Lived Signals）"></a>有限或者短期的信号（Finite Or Short-Lived Signals）</h3><p>RAC内存管理最重要的指导原则是，订阅关系会在完成或者发生错误后终结，并且订阅者会被移除。</p>
<p>举个栗子，假如你有如下代码在view controller里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.disposable = [signal subscribeCompleted:^&#123;</span><br><span class="line">    doSomethingPossiblyInvolving(self);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>内存管理就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view controller -&gt; RACDisposable -&gt; RACSignal -&gt; RACSubscriber -&gt; view controller</span><br></pre></td></tr></table></figure>
<p>然而，一旦signal结束这种<code>RACSignal -&gt; RACSubscriber</code>关系就会被拆除 ，从而打破了引用环。<br>通常，这正是你所需要的，因为RACSignal的生命周期自然会匹配事件流的逻辑生命周期。</p>
<h3 id="无限信号-Infinite-Signals"><a href="#无限信号-Infinite-Signals" class="headerlink" title="无限信号(Infinite Signals)"></a>无限信号(Infinite Signals)</h3><p>无线信号（或者存活时间太久以致它们可能是无限的信号），并不会自动释放。这时候<code>disposables</code>就派上用场了<br><strong>处理（也就是调用<code>disposable</code>的<code>dispose</code>方法）订阅关系将会移除关联的订阅者，</strong>，并将优雅地清理相关的资源。对于订阅者而言，就好像信号已经完成或者发生了错误。其他的订阅者并不受影响。<br>如果您必须手动管理订阅的生命周期，<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/Documentation/DesignGuidelines.md#avoid-explicit-subscriptions-and-disposal" target="_blank" rel="noopener">那么可能有更好的方法来执行您想要的操作</a>。</p>
<h3 id="来自于self的信号（Signals-Derived-from-self）"><a href="#来自于self的信号（Signals-Derived-from-self）" class="headerlink" title="来自于self的信号（Signals Derived from self）"></a>来自于<code>self</code>的信号（Signals Derived from self）</h3><p>虽然，这里仍然存在一些棘手的中间情况。任何时候信号的生命周期都与调用范围联系在一起，你将有一个更难打破的引用环。<br>这通常发生在使用<code>RACObserve()</code>关联<code>self</code>的key path，并需要使用<code>block</code>捕获<code>self</code>的时候。<br>最简单的办法是使用__weak</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__weak id weakSelf = self;</span><br><span class="line">[RACObserve(self, username) subscribeNext:^(NSString *username) &#123;</span><br><span class="line">    id strongSelf = weakSelf;</span><br><span class="line">    [strongSelf validateUsername];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>或者，在引入 <a href="https://github.com/jspahrsummers/libextobjc/blob/master/extobjc/EXTScope.h" target="_blank" rel="noopener">EXTScope.h</a> 头文件后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">[RACObserve(self, username) subscribeNext:^(NSString *username) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    [self validateUsername];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>（如果对象不支持弱引用，分别使用，<strong>unsafe_unretained或者@unsafeify替换</strong>weak或@weakify）</p>
<p>不过，<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/Documentation/DesignGuidelines.md#avoid-explicit-subscriptions-and-disposal" target="_blank" rel="noopener">你可以使用更好的模式</a>。例如，上面的例子可以写成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ self  rac_liftSelector：@selector（validateUsername：）withSignals：RACObserve（self，username），nil ];</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * validated = [ RACObserve（self，username）map： ^（NSString * username）&#123;</span><br><span class="line">     //将验证逻辑放在这里。</span><br><span class="line">    return @ YES ; </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>跟无限信号一样，这可以避免在信号流的<code>block</code>中持有<code>self</code></p>
<hr>
<p>为了有效使用ReactiveCocoa，以上就是你所需要的全部信息。然而，还有一点需要解决，只是出于技术上的好奇，或者任何对RAC有贡献的人。</p>
<p>“不需要持有”的设计目标引出一个问题：我们怎么知道一个信号何时被释放？如果只是创建而没有被持有呢？<br>答案是<em>我们无法知道</em>，但是我们通常可以假设调用者会在当前运行循环迭代中保留信号，如果他们想保留它的话。<br>所以：</p>
<ol>
<li>创建的信号会自动添加到全局活动信号集。</li>
<li>该信号将等待主线程RunLoop的一次循环，然后如果它没有订户，则从活动集中移出。除非信号以某种方式保留，否则它将在此处释放</li>
<li>如果信号在RunLoop迭代中被订阅了，它将会被保留在信号集里</li>
<li>当所有订阅者都被移除了，步骤2就会被触发</li>
</ol>
<p>如果RunLoop以递归的方式运转，这将适得其反。不过大多数或全部情况下ReactiveCocoa框架会简化使用者的代码。 </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/ReactiveCocoa-基本操作符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/ReactiveCocoa-基本操作符/" itemprop="url">
                  ReactiveCocoa 基本操作符
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T14:03:12+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近打算好好学习下ReactiveCocoa，个人认为最好的学习方式就是看官方文档。这篇基本操作符的介绍，也是翻译自<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/Documentation/BasicOperators.md" target="_blank" rel="noopener">官方文档</a>。</p>
</blockquote>
<h1 id="基本操作符"><a href="#基本操作符" class="headerlink" title="基本操作符"></a>基本操作符</h1><p>本文档解释了ReactiveCocoa中最常用的操作符，并包含了演示其用法的的示例<br>适用于<strong><code>sequences</code></strong> 和 <strong><code>signal</code></strong>的操作符被称为<strong><code>stream</code></strong>的操作符</p>
<h2 id="执行信号产生的副作用"><a href="#执行信号产生的副作用" class="headerlink" title="执行信号产生的副作用"></a>执行信号产生的副作用</h2><p>大多数信号都是冷信号，这意味着直到被<strong>订阅</strong>它们才会生效。<br>订阅后，信号或者他的订阅者可以执行，例如打印到控制台、发起网络请求、更新UI等操作。</p>
<p>###订阅（Subscription）</p>
<p><code>-subscribe</code>系列方法可以访问<code>signal</code>的当前以及未来的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *letters = [@&quot;A B C D E F G H I&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence.signal;</span><br><span class="line"></span><br><span class="line">// Outputs: A B C D E F G H I</span><br><span class="line">[letters subscribeNext:^(NSString *x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>对于冷信号来说，每一次订阅都将执行一次副作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__block unsigned subscriptions = 0;</span><br><span class="line">   </span><br><span class="line">   RACSignal *loggingSignal = [RACSignal createSignal:^RACDisposable *(id &lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       subscriptions++;</span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">       return nil;</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   // Outputs:</span><br><span class="line">   // subscription 1</span><br><span class="line">   [loggingSignal subscribeCompleted:^&#123;</span><br><span class="line">       NSLog(@&quot;subscriptions %lu&quot;, subscriptions);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   // Outputs:</span><br><span class="line">   // subscription 2</span><br><span class="line">   [loggingSignal subscribeCompleted:^&#123;</span><br><span class="line">       NSLog(@&quot;subscriptions %lu&quot;, subscriptions);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<p>这种行为可以使用过<code>connection</code>来改变。</p>
<p>###注入副作用（Injecting effect）</p>
<p><code>-do</code>系列方法可以给<code>signal</code>添加副作用，而不需要<strong>订阅</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__block unsigned subscriptions = 0;</span><br><span class="line"></span><br><span class="line">    RACSignal *loggingSignal = [RACSignal createSignal:^RACDisposable *(id &lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        subscriptions++;</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // Does not output anything yet</span><br><span class="line">    [loggingSignal doCompleted:^&#123;</span><br><span class="line">        NSLog(@&quot;about to complete subscription %u&quot;, subscriptions);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // Outputs:</span><br><span class="line">    // about to complete subscription 1</span><br><span class="line">    // subscription 1</span><br><span class="line">    [loggingSignal subscribeCompleted:^&#123;</span><br><span class="line">        NSLog(@&quot;subscriptions %lu&quot;, subscriptions);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h2 id="变换Streams"><a href="#变换Streams" class="headerlink" title="变换Streams"></a>变换Streams</h2><p>变换操作符可以将单个<code>stream</code>变换成一个新的<code>stream</code></p>
<h3 id="映射（Mapping）"><a href="#映射（Mapping）" class="headerlink" title="映射（Mapping）"></a>映射（Mapping）</h3><p><code>-map:</code>方法用于将<code>stream</code>中的值转换，并基于转换后的新值创建一个新的<code>stream</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *letters = [@&quot;A, B,C,D,E,F G,H, I&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence;</span><br><span class="line">    </span><br><span class="line">// Contains: AA BB CC DD EE FF GG HH II</span><br><span class="line">[letters map:^id(NSString * value) &#123;</span><br><span class="line">   value = [value stringByAppendingString:value];</span><br><span class="line">   return value;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="过滤（Filtering）"><a href="#过滤（Filtering）" class="headerlink" title="过滤（Filtering）"></a>过滤（Filtering）</h3><p><code>-filter:</code>方法使用一个block，来筛选出符合条件的值，并生成新的<code>stream</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *numbers = [@&quot;1 2 3 4 5 6 7 8 9&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence;</span><br><span class="line">    </span><br><span class="line">// Contains: 2 4 6 8</span><br><span class="line">RACSequence *filtered = [numbers filter:^BOOL(NSNumber * value) &#123;</span><br><span class="line">   return value.intValue % 2 == 0;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="结合流（Combining-Streams）"><a href="#结合流（Combining-Streams）" class="headerlink" title="结合流（Combining Streams）"></a>结合流（Combining Streams）</h2><p>结合操作符可以将多个stream合并成单个stream</p>
<h3 id="连接（Concatenating）"><a href="#连接（Concatenating）" class="headerlink" title="连接（Concatenating）"></a>连接（Concatenating）</h3><p><code>-concat:</code>方法可以将一个<code>stream</code>拼接在另一个<code>stream</code>后面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *letters = [@&quot;A B C D E F G H I&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence;</span><br><span class="line">RACSequence *numbers = [@&quot;1 2 3 4 5 6 7 8 9&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence;</span><br><span class="line"></span><br><span class="line">// Contains: A B C D E F G H I 1 2 3 4 5 6 7 8 9</span><br><span class="line">RACSequence *concatenated = [letters concat:numbers];</span><br></pre></td></tr></table></figure>
<h3 id="扁平化（Flattening）"><a href="#扁平化（Flattening）" class="headerlink" title="扁平化（Flattening）"></a>扁平化（Flattening）</h3><p><code>-flatten</code>操作符用于包含<code>stream</code>的<code>stream</code>，将<code>stream</code>中的值也就是<code>stream</code>，组合成一个新的<code>stream</code></p>
<p>序列的连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *letters = [@&quot;A B C D E F G H I&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence;</span><br><span class="line">RACSequence *numbers = [@&quot;1 2 3 4 5 6 7 8 9&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence;</span><br><span class="line">RACSequence *sequenceOfSequences = @[letters, numbers].rac_sequence;</span><br><span class="line">   </span><br><span class="line">// Contains: A B C D E F G H I 1 2 3 4 5 6 7 8 9</span><br><span class="line">RACSequence *flattenedSequence = [sequenceOfSequences flatten];</span><br></pre></td></tr></table></figure>
<p>信号的合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *letters = [RACSubject subject];</span><br><span class="line">RACSubject *numbers = [RACSubject subject];</span><br><span class="line">RACSignal *signalOfSignals = [RACSignal createSignal:^ RACDisposable * (id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:letters];</span><br><span class="line">    [subscriber sendNext:numbers];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *flattened = [signalOfSignals flatten];</span><br><span class="line"></span><br><span class="line">// Outputs: A 1 B C 2</span><br><span class="line">[flattened subscribeNext:^(NSString *x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[letters sendNext:@&quot;A&quot;];</span><br><span class="line">[numbers sendNext:@&quot;1&quot;];</span><br><span class="line">[letters sendNext:@&quot;B&quot;];</span><br><span class="line">[letters sendNext:@&quot;C&quot;];</span><br><span class="line">[numbers sendNext:@&quot;2&quot;];</span><br></pre></td></tr></table></figure>
<h3 id="映射和扁平化（Mapping-and-Flattening）"><a href="#映射和扁平化（Mapping-and-Flattening）" class="headerlink" title="映射和扁平化（Mapping and Flattening）"></a>映射和扁平化（Mapping and Flattening）</h3><p>扁平化本身并不是很意思，但是理解其工作原理对于<code>flattenMap</code>操作符来说很重要</p>
<p><strong><code>-flattenMap:</code></strong>操作符用于将流中的每一个值转换成一个新的流，然后再将所有返会的流扁平化成单个的流。换句话说，就是先执行<code>-flatten</code>操作再执行<code>-map:</code>操作。</p>
<p><strong><code>-flattenMap:</code>操作符可以用来拓展和编辑序列
</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *numbers = [@&quot;1 2 3 4 5 6 7 8 9&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence;</span><br><span class="line"></span><br><span class="line">// Contains: 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9</span><br><span class="line">RACSequence *extended = [numbers flattenMap:^RACStream *(NSNumber * value) &#123;</span><br><span class="line">   return @[value, value].rac_sequence;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">// Contains: 1_ 3_ 5_ 7_ 9_</span><br><span class="line">RACSequence*edited = [numbers flattenMap:^RACStream *(NSString *value) &#123;</span><br><span class="line">   if(value.intValue %2 == 0)&#123;</span><br><span class="line">       return [RACSequence empty];</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       return  [RACSequence return:[value stringByAppendingString:@&quot;_&quot;]];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>也可以用来创建多个自动重组的信号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *letters = [@&quot;A B C D E F G H I&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence.signal;</span><br><span class="line"></span><br><span class="line">[[letters flattenMap:^(NSString *letter) &#123;</span><br><span class="line">   return [RACSignal return:[letter stringByAppendingString:letter]];</span><br><span class="line">&#125;] subscribeCompleted:^&#123;</span><br><span class="line">   NSLog(@&quot;All database entries saved successfully.&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="组合信号（Combining-Signal）"><a href="#组合信号（Combining-Signal）" class="headerlink" title="组合信号（Combining Signal）"></a>组合信号（Combining Signal）</h2><p>连接操作符可以将多个信号组合成单个信号</p>
<h3 id="序列化（Sequencing）"><a href="#序列化（Sequencing）" class="headerlink" title="序列化（Sequencing）"></a>序列化（Sequencing）</h3><p><code>-then:</code>操作符开始于一个原始信号，并等待其完成，然后只转发新信号的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *letters = [@&quot;A B C D E F G H I&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence.signal;</span><br><span class="line">RACSignal *sequenced = [[letters doNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,x);</span><br><span class="line">    &#125;] then:^RACSignal * &#123;</span><br><span class="line">        return [@&quot;1 2 3 4 5 6 7 8 9&quot; componentsSeparatedByString:@&quot; &quot;].rac_sequence.signal;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="合并（Merging）"><a href="#合并（Merging）" class="headerlink" title="合并（Merging）"></a>合并（Merging）</h3><p><code>+merge:</code>操作符将那些从多个信号到达的值，转发到单个信号流中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *letters = [RACSubject subject];</span><br><span class="line">RACSubject *numbers = [RACSubject subject];</span><br><span class="line">RACSignal *merged = [RACSignal merge:@[ letters, numbers ]];</span><br><span class="line"></span><br><span class="line">// Outputs: A 1 B C 2</span><br><span class="line">[merged subscribeNext:^(NSString *x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[letters sendNext:@&quot;A&quot;];</span><br><span class="line">[numbers sendNext:@&quot;1&quot;];</span><br><span class="line">[letters sendNext:@&quot;B&quot;];</span><br><span class="line">[letters sendNext:@&quot;C&quot;];</span><br><span class="line">[numbers sendNext:@&quot;2&quot;];</span><br></pre></td></tr></table></figure>
<h3 id="合并最新值（Combining-latest-values）"><a href="#合并最新值（Combining-latest-values）" class="headerlink" title="合并最新值（Combining latest values）"></a>合并最新值（Combining latest values）</h3><p><strong><code>+combineLatest:</code></strong> 和 <strong><code>+combineLatest:reduce:</code></strong>方法将观察多个信号的变化，当其中一个信号发生变化时，就将所有信号的最新值发送出去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *letters = [RACSubject subject];</span><br><span class="line">RACSubject *numbers = [RACSubject subject];</span><br><span class="line">RACSignal *combined = [RACSignal</span><br><span class="line">    combineLatest:@[ letters, numbers ]</span><br><span class="line">    reduce:^(NSString *letter, NSString *number) &#123;</span><br><span class="line">        return [letter stringByAppendingString:number];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">// Outputs: B1 B2 C2 C3</span><br><span class="line">[combined subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[letters sendNext:@&quot;A&quot;];</span><br><span class="line">[letters sendNext:@&quot;B&quot;];</span><br><span class="line">[numbers sendNext:@&quot;1&quot;];</span><br><span class="line">[numbers sendNext:@&quot;2&quot;];</span><br><span class="line">[letters sendNext:@&quot;C&quot;];</span><br><span class="line">[numbers sendNext:@&quot;3&quot;];</span><br></pre></td></tr></table></figure>
<p><strong>注意，组合信号只会在所有输入发送至少一个输入时发送其第一个值。在上面的示例中，@”A”从未转发，因为numbers尚未发送值。</strong></p>
<h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p><code>-switchToLatest</code>操作符作用于“信号的信号”，并且总是转发从最新的信号的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *letters = [RACSubject subject];</span><br><span class="line">RACSubject *numbers = [RACSubject subject];</span><br><span class="line">RACSubject *signalOfSignals = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">RACSignal *switched = [signalOfSignals switchToLatest];</span><br><span class="line"></span><br><span class="line">// Outputs: A B 1 D</span><br><span class="line">[switched subscribeNext:^(NSString *x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:letters];</span><br><span class="line">[letters sendNext:@&quot;A&quot;];</span><br><span class="line">[letters sendNext:@&quot;B&quot;];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:numbers];</span><br><span class="line">[letters sendNext:@&quot;C&quot;];</span><br><span class="line">[numbers sendNext:@&quot;1&quot;];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:letters];</span><br><span class="line">[numbers sendNext:@&quot;2&quot;];</span><br><span class="line">[letters sendNext:@&quot;D&quot;];</span><br></pre></td></tr></table></figure>
<p>以上就是ReactiveCocoa最常用的操作符的介绍</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/07/找一个靠谱的iOS面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/07/找一个靠谱的iOS面试题/" itemprop="url">
                  找一个靠谱的iOS面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-07T13:32:01+08:00">2018-04-07</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-风格纠错题-知识点官方文档"><a href="#1-风格纠错题-知识点官方文档" class="headerlink" title="1. 风格纠错题 知识点官方文档"></a>1. 风格纠错题 <a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html" target="_blank" rel="noopener">知识点官方文档</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">    UserSex_Man,</span><br><span class="line">    UserSex_Woman</span><br><span class="line">&#125; UserSex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface UserModel : NSObject</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) NSString *name;</span><br><span class="line">@property(assign, nonatomic) int age;</span><br><span class="line">@property (nonatomic, assign) UserSex sex;</span><br><span class="line"></span><br><span class="line">-(id) initUserModelWithUserName:(NSString*)name withAge:(int) age</span><br><span class="line"></span><br><span class="line">-(void) doLogin;</span><br></pre></td></tr></table></figure>
<p>考查知识点：</p>
<ul>
<li>enum NS_ENUM NS_OPTIONS</li>
<li>不可变类型数据（NSString、NSArray、NSDictionary）的修饰符的使用</li>
<li>函数命名规范</li>
<li>应避免使用基本类型，建议使用Foundation数据类型</li>
</ul>
<p>###知识点：</p>
<h4 id="enum枚举类型建议使用-NS-ENUM-或者-NS-OPTIONS-宏来定义"><a href="#enum枚举类型建议使用-NS-ENUM-或者-NS-OPTIONS-宏来定义" class="headerlink" title="enum枚举类型建议使用 NS_ENUM 或者 NS_OPTIONS 宏来定义"></a>enum枚举类型建议使用 <code>NS_ENUM</code> 或者 <code>NS_OPTIONS</code> 宏来定义</h4><p><code>NS_ENUM</code>和<code>NS_OPTIONS</code>提供了一种简明、简单的方法来定义基于C语言的枚举和选项，这些宏提高了Xcode中的代码的完成性，并明确指定了枚举和选项的类型和大小。</p>
<ul>
<li><code>NS_ENUM</code>和<code>NS_OPTIONS</code> 的区别</li>
</ul>
<p>如果需要以按位或操作来组合的枚举应该使用<code>NS_OPTIONS</code>，；如枚举不需要相互组合，则可以使用<code>NS_ENUM</code>来定义。也就是<code>NS_OPTIONS</code>适合多挣枚举类型同时存在的情况，而<code>NS_ENUM</code>适合只同时只存在一种枚举的情况</p>
<h4 id="不可变类型数据（NSString、NSArray、NSDictionary）的修饰符的使用，属性的修饰符"><a href="#不可变类型数据（NSString、NSArray、NSDictionary）的修饰符的使用，属性的修饰符" class="headerlink" title="不可变类型数据（NSString、NSArray、NSDictionary）的修饰符的使用，属性的修饰符"></a>不可变类型数据（NSString、NSArray、NSDictionary）的修饰符的使用，属性的修饰符</h4><p>不可变类型数据（NSString、NSArray、NSDictionary），都有其对应的可变类型，而且是不可变类型的子类，如果使用 strong来修饰NSString，那么NSMutableString也可以赋值给该属性，如果NSMutableString赋值给NSString后，又被修改了，那么就会出现跟预想不一致的情况了，而copy修饰NSString，在setter方法中只会将NSMutableString复制一份，而不会保留，就算NSMutableString后来改变了也没有关系</p>
<h4 id="函数命名规范"><a href="#函数命名规范" class="headerlink" title="函数命名规范"></a>函数命名规范</h4><ol>
<li>instancetype，使用instancetype关键字作为返回类的实例的方法的返回类型，而不是使用id作为返回类型，这可以提高代码的安全性</li>
<li>连接第二参数不要使用with</li>
<li>函数命名不要使用两个动词</li>
</ol>
<h4 id="应避免使用基本类型，建议使用Foundation数据类型"><a href="#应避免使用基本类型，建议使用Foundation数据类型" class="headerlink" title="应避免使用基本类型，建议使用Foundation数据类型"></a>应避免使用基本类型，建议使用Foundation数据类型</h4><p>Foundation数据在不同系统上长度是不一样的，在32位系统上int占4个字节 NSInterge也是4个字节，但是在64位系统上NSInterge占8个字节。总的来说Foundation数据兼容性会更好一下，使用Foundation数据会比使用基本类型，代码更健壮一点</p>
<p>####修改后答案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM (NSInteger, CYSex) &#123;</span><br><span class="line">    CYSexMan,</span><br><span class="line">    CYSexWoman</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface UserModel : NSObject</span><br><span class="line"></span><br><span class="line">@property(nonatomic, copy, readonly) NSString *name;</span><br><span class="line">@property(nonatomic, assign, readonly) NSUInterge age;</span><br><span class="line">@property(nonatomic, assign, readonly) CYSex sex;</span><br><span class="line"></span><br><span class="line">-(instancetype) userModelWithUserName:(NSString*)name age:(int) age</span><br><span class="line"></span><br><span class="line">-(void) login;</span><br></pre></td></tr></table></figure>
<h3 id="2-什么情况下使用weak关键字，相比assign有什么不同"><a href="#2-什么情况下使用weak关键字，相比assign有什么不同" class="headerlink" title="2. 什么情况下使用weak关键字，相比assign有什么不同"></a>2. 什么情况下使用weak关键字，相比assign有什么不同</h3><p><img src="https://raw.githubusercontent.com/Mochangxing/blogImages/master/media/15230746670632/15230825379588.jpg" alt=""></p>
<ul>
<li>weak关键字的作用：weak关键字是为了解决strong带来的循环引用的问题而生的，它不会使所引用的对象的引用计数+1，所以也就打破了引用环。weak关键字修饰的属性在其指向的对象销毁了，该属性也会被置为nil。</li>
<li>assign关键字也不会使所引用的对象引用计数+1，和weak的不同点在于，其引用的对象销毁时，assign关键字修饰的属性不会被置为nil，仍然指向了原来的地址，形成野指针。assign赋值方式：复制数据而不是复制引用</li>
</ul>
<p>结论：weak关键字适用于可能出现循环引用的地方</p>
<h3 id="3-怎么使用copy关键字？"><a href="#3-怎么使用copy关键字？" class="headerlink" title="3.怎么使用copy关键字？"></a>3.怎么使用copy关键字？</h3><ol>
<li>NSString、NSArray、NSDictionary等经常使用copy关键字，因为他们有对应的可变数据类型</li>
<li>block也经常使用copy关键字，因为在方法体内block是被分配在栈上的，使用copy之后就会分配在堆上。然后就可以在作用域外访问了</li>
</ol>
<h3 id="4-这个写法会出什么问题：-property-copy-NSMutableArray-array"><a href="#4-这个写法会出什么问题：-property-copy-NSMutableArray-array" class="headerlink" title="4. 这个写法会出什么问题： @property (copy) NSMutableArray *array;"></a>4. 这个写法会出什么问题： @property (copy) NSMutableArray *array;</h3><ol>
<li>copy修饰的话，在赋值时会变成NSArray不可变对象，那么进行增删改操作时会crash</li>
<li>property默认为 atomic，这会影响性能。</li>
</ol>
<p>一般情况下并不需要把属性声明为atomic，因为这并不能保证线程安全，只能保证读写的原子性。例如：一个线程连续多次读取属性值时，也有可能读到不同的值。</p>
<h3 id="5-如何让自己的类用copy修饰符？如何重写带copy关键字的setter？"><a href="#5-如何让自己的类用copy修饰符？如何重写带copy关键字的setter？" class="headerlink" title="5.如何让自己的类用copy修饰符？如何重写带copy关键字的setter？"></a>5.如何让自己的类用copy修饰符？如何重写带copy关键字的setter？</h3><ol>
<li>若想让自己的类的对象具备copy功能，则需要实现NSCopy协议，如果自定义的对象分为可变和不可变两个版本，那么还应该实现NSMutableCopy协议</li>
<li>重写如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(void) setName:(NSString *)name&#123;</span><br><span class="line">    _name = [name copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-property的本质是什么？ivar、getter、和setter是如何生成并添加到这个类中的"><a href="#6-property的本质是什么？ivar、getter、和setter是如何生成并添加到这个类中的" class="headerlink" title="6.@property的本质是什么？ivar、getter、和setter是如何生成并添加到这个类中的?"></a>6.@property的本质是什么？ivar、getter、和setter是如何生成并添加到这个类中的?</h3><blockquote>
<p>@property本质上等于 实例变量 + 存取方法（getter、setter）</p>
</blockquote>
<blockquote>
<p>ivar、getter、和setter是编译器通过<strong>autosynthesis（自动合成）</strong>添加到类中的</p>
</blockquote>
<h3 id="7-protocol-和category中如何使用-property？"><a href="#7-protocol-和category中如何使用-property？" class="headerlink" title="7. protocol 和category中如何使用@property？"></a>7. protocol 和category中如何使用@property？</h3><ol>
<li>protocol中使用@property，只会生成getter和setter方法声明，在protocol中使用property的目的是，希望实现该协议的类能实现该属性</li>
<li>category中使用@property也是只会生成getter和setter方法声明，如果真的需要给category增加属性需要使用一下两个函数：<code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code></li>
</ol>
<h3 id="8-Runtime如何实现weak属性"><a href="#8-Runtime如何实现weak属性" class="headerlink" title="8.Runtime如何实现weak属性"></a>8.Runtime如何实现weak属性</h3><p>Runtime其实是通过一张weak表来实现weak属性的，weak表其实是一张Hash表，key为weak指向的对象的内存地址，value则是所有weak指针的组成的数组。当weak指向的对象销毁时，Runtime就会从weak表中索引到所有指向改地址的weak指针，并全部置为nil</p>
<ul>
<li>子问题：如何让不使用weak修饰的property，拥有weak的效果？</li>
</ul>
<ol>
<li>重写setter方法，使用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN);</span><br></pre></td></tr></table></figure>
<p>这样相当于使用assign修饰了property</p>
<ol start="2">
<li>第二步需要在<code>object</code>对象销毁时，将property对应的实例变量<code>_object</code>置为nil；这一步的实现需要借助<code>category</code>以及<strong>关联对象</strong>，原理是当一个对象被销毁时，它的关联对象也会被销毁，那么只要在关联对象的的<code>dealloc</code>方法里执行block就可以达到将 实例变量<code>_object</code>置为nil的目的了</li>
</ol>
<p>setter的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(NSObject *)object</span><br><span class="line">&#123;</span><br><span class="line">  objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">  [object cyl_runAtDealloc:^&#123;</span><br><span class="line">      _object = nil;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>category的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(void) cyl_runAtDealloc:(voidBlock) block&#123;</span><br><span class="line">   CYLBlockExecutor *executor = [CYLBlockExecutor initWithBlock:block];</span><br><span class="line">   objc_setAssociatedObject(self, &quot;runAtDeallocBlockKey&quot;, executor, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CYLBlockExecutor的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithBlock:(voidBlock)aBlock</span><br><span class="line">&#123;</span><br><span class="line">   self = [super init];</span><br><span class="line">   if (self) &#123;</span><br><span class="line">       _block = [aBlock copy];</span><br><span class="line">   &#125;</span><br><span class="line">   return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">   _block ? _block() : nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-property中有哪些属性关键字"><a href="#9-property中有哪些属性关键字" class="headerlink" title="9.@property中有哪些属性关键字"></a>9.@property中有哪些属性关键字</h3><ol>
<li>原子性：atomic、nonatomic</li>
<li>读写权限：readwrite、readonly</li>
<li>内存管理语义：strong、weak、assign、copy、unsafe_unretained</li>
<li>方法名: getter=<name>, setter=<name></name></name></li>
</ol>
<h3 id="10-weak属性需要在dealloc中置为nil吗？"><a href="#10-weak属性需要在dealloc中置为nil吗？" class="headerlink" title="10.weak属性需要在dealloc中置为nil吗？"></a>10.weak属性需要在dealloc中置为nil吗？</h3><p>不需要，ARC会自动处理的</p>
<h3 id="11-synthesize和-dynamic分别有什么作用？"><a href="#11-synthesize和-dynamic分别有什么作用？" class="headerlink" title="11.@synthesize和@dynamic分别有什么作用？"></a>11.@synthesize和@dynamic分别有什么作用？</h3><ol>
<li>@property有两个对应的词：@synthesize和@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是@synthesize var = _var;</li>
<li>@synthesize的语义是如果你没有实现getter和setter那么编译器会自动帮你实现这两个方法</li>
<li>@dynamic是告诉编译器：属性的getter和setter由开发者自己实现。@dynamic一般用来实现动态绑定，需要重写<code>+ (BOOL) resolveInstanceMethod:(SEL)sel</code>方法</li>
</ol>
<h3 id="12-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><a href="#12-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？" class="headerlink" title="12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"></a>12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h3><h3 id="13-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"><a href="#13-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？" class="headerlink" title="13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"></a>13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h3><h3 id="14-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？"><a href="#14-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？" class="headerlink" title="14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？"></a>14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</h3><h3 id="15-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？"><a href="#15-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？" class="headerlink" title="15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？"></a>15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3><h3 id="16-objc中向一个nil对象发送消息将会发生什么？"><a href="#16-objc中向一个nil对象发送消息将会发生什么？" class="headerlink" title="16. objc中向一个nil对象发送消息将会发生什么？"></a>16. objc中向一个nil对象发送消息将会发生什么？</h3><p> objc在想一个对象发送消息时，runtime会根据对象的<code>isa</code>指针找到该对象所属的类，然后再该类的方法列表和其父类的方列表里查找响应的方法，然后再发送消息的时候，objc_msgSend不会有返回值，所谓的返回值都是在发生方法调用的时候执行的。如果向nil对象发送消息，首先就会在寻找对象的<code>isa</code>指针时就返回了，也就不会发生任何错误了</p>
<h3 id="17-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？"><a href="#17-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？" class="headerlink" title="17. objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？"></a>17. objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h3><p>[objc foo]会在编译时，被转意为：objc_msgSend(obj, @selector(foo))</p>
<h3 id="18-什么情况下会报unrecognized-selector异常"><a href="#18-什么情况下会报unrecognized-selector异常" class="headerlink" title="18. 什么情况下会报unrecognized selector异常"></a>18. 什么情况下会报unrecognized selector异常</h3><p>这就涉及到消息的发送流程了：</p>
<ol>
<li>objc在向一个对象发送消息时，Runtime会根据对象的isa指针找到对象所属的类，然后从方法缓存里查找对应的方法</li>
<li>若上一步找不到对应的方法，则会从方法列表里查找，如果还是找不到就会到父类的方法列表里查找直到NSObject类</li>
<li>这时如果还是找不到，就会触发Method resolution，这时你有机会提供一个函数的实现，添加到类中，如果添加了实现，这时就会重新启动一次消息发送流程，Method resolution没有提供实现的函数的话，就会触发消息转发</li>
<li>Fast Forwarding：如果目前对象实现了-forwardingForSelector方法，Runtime就会调用该方法，让目标对象提供一个可以响应该消息的对象，只要不返回nil或者self，就会重新触发消息发送</li>
<li>Normal Forwarding：Fast Forwarding失败了的话，就是启动Normal Forwarding。首先Runtime会发送-methodForSignaturForSelector：消息获取函数的参数和返回值，然后创建一个NSInvocation对象并发送 -forwardInvocation:消息给目标对象</li>
</ol>
<p>如果以上流程走完，仍没有响应消息的函数，则会报unrecognized selector异常</p>
<h3 id="19-一个objc对象如何进行内存布局？（考虑有父类的情况）"><a href="#19-一个objc对象如何进行内存布局？（考虑有父类的情况）" class="headerlink" title="19. 一个objc对象如何进行内存布局？（考虑有父类的情况）"></a>19. 一个objc对象如何进行内存布局？（考虑有父类的情况）</h3><ul>
<li>父类的成员变量和自己的成员变量都存放在该对象的存错空间中</li>
<li><p>对象的内部有一个isa指针，指向他的类对象。类对象中存放着： </p>
<pre><code>* 每个对象的方法列表
* 成员变量的列表
* 属性的列表
* 类对象的内部也有一个isa指针指向元类对象（meta class），元类对象中存放着类方法列表，类对象内部还有一个superclass指针指向父类对象
</code></pre></li>
</ul>
<p><img src="media/15230746670632/15231080093572.jpg" alt=""></p>
<h3 id="20-一个objc对象的isa的指针指向什么？有什么作用？"><a href="#20-一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="20.一个objc对象的isa的指针指向什么？有什么作用？"></a>20.一个objc对象的isa的指针指向什么？有什么作用？</h3><p>指向类对象，可以查找对象上的方法</p>
<h3 id="21-下面的代码输出什么"><a href="#21-下面的代码输出什么" class="headerlink" title="21. 下面的代码输出什么"></a>21. 下面的代码输出什么</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation Son:Father</span><br><span class="line">-(id) init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if(self)&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass[self class]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass[super class]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考察的知识点：self与super关键字</p>
<p>self是类的隐藏参数，指向当前调用方法的类的实例<br>super并不是指向父类的指针，它和self是指向同一个接收者，不同点在于：</p>
<pre><code>* [self class] 编译后 objc_msgSend(obj, @selector(class))；
* [super class] 编译后 objc_msgSendSuper(obj, @selector(class))；
</code></pre><p>但是最后调用的都是NSObject的这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以最后输出都是 Son</p>
<h3 id="22-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"><a href="#22-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）" class="headerlink" title="22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"></a>22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3><h3 id="23-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？"><a href="#23-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？" class="headerlink" title="23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？"></a>23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3><p>不需要<br>它们会在NSObject -dealloc调用的object_dispose()方法中释放掉</p>
<p>对象的内存释放时间表：</p>
<pre><code>1. 调用release：引用计数变为0
2. 子类调用 -dealloc
3. NSObject 调用-dealloc

4.调用object_dispose()
  * 为C++实例变量们（ivars）调用析构函数
  * 为了ARC状态下的 实例变量们（ivars）调用releas
  * 释放所有使用runtime associate 方法关联的对象
  * 释放所有__weak引用
  * 调用free
</code></pre><h3 id="24-objc中的类方法和实例方法有什么本质区别和联系？"><a href="#24-objc中的类方法和实例方法有什么本质区别和联系？" class="headerlink" title="24. objc中的类方法和实例方法有什么本质区别和联系？"></a>24. objc中的类方法和实例方法有什么本质区别和联系？</h3><h3 id="25-objc-msgForward函数是做什么的？直接调用他会发生什么？"><a href="#25-objc-msgForward函数是做什么的？直接调用他会发生什么？" class="headerlink" title="25. _objc_msgForward函数是做什么的？直接调用他会发生什么？"></a>25. _objc_msgForward函数是做什么的？直接调用他会发生什么？</h3><p><code>_objc_msgForward</code>是用来实现消息转发的：向一个对象发送消息，但它并没有对应的实现的时候，<code>_objc_msgForward</code>会尝试消息转发</p>
<p>直接调用_objc_msgForward是非常危险的事，直接调用<code>_objc_msgForward</code>，会跳过查找IMP的过程，直接出发消息转发，如果用不好会直接导致程序Crash。但是如果用得好，能做很多非常酷的事，比如热修复。</p>
<h3 id="26-runtime如何实现weak变量的自动置nil？"><a href="#26-runtime如何实现weak变量的自动置nil？" class="headerlink" title="26. runtime如何实现weak变量的自动置nil？"></a>26. runtime如何实现weak变量的自动置nil？</h3><p>同第8题 weak的实现</p>
<h3 id="27能否向编译后得到的类增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"><a href="#27能否向编译后得到的类增加实例变量？能否向运行时创建的类中添加实例变量？为什么？" class="headerlink" title="27能否向编译后得到的类增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"></a>27能否向编译后得到的类增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3><ul>
<li>不能向编译后的类增加实例变量</li>
<li>可以向运行时创建的类添加实例变量</li>
</ul>
<p>解释：<br>编译后的类，类结构体中的objc_ivar_list 实例变量链表和实例变量的内存大小 instance_size都已经确定了，所以不能向编译后的类增加实例变量</p>
<p>运行时创建的类可以增加实力变量。不过得在调用<code>objc_allocateClassPair</code>之后，<code>objc_registerClassPair</code>之前。</p>
<p>增加方法则没有限制</p>
<h3 id="28-RunLoop与线程的关系"><a href="#28-RunLoop与线程的关系" class="headerlink" title="28 RunLoop与线程的关系"></a>28 RunLoop与线程的关系</h3><p>RunLoop与线程的紧密相连的，每个线程都有一个对应的RunLoop。<br>不过只有主线程的RunLoop默认是开启的</p>
<p>其他线程的RunLoop默认不开启 必要时得手动获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop*runloop = [NSRunLoop currentRunLoop];</span><br></pre></td></tr></table></figure>
<h3 id="29-RunLoop的mode的作用是什么？"><a href="#29-RunLoop的mode的作用是什么？" class="headerlink" title="29.RunLoop的mode的作用是什么？"></a>29.RunLoop的mode的作用是什么？</h3><p>mode是用来处理不同分组的Source/Timer/Obsever事件的，系统提供的mode有5种：</p>
<ul>
<li><p>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认。空闲状态</p>
</li>
<li><p>UITrackingRunLoopMode：ScrollView的滑动时</p>
</li>
<li><p>GSEventReceiveRunLoopMode</p>
</li>
<li>UIInitializationRunLoopMode：启动时</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合</li>
</ul>
<p>系统公开提供的Mode有两个：</p>
<ul>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认。空闲状态</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合</li>
</ul>
<p>RunLoop只能运行在一种Mode下，如果要切换Mode，需要退出RunLoop再重新启动，当ScrollView滑动时，主线程RunLoop会由NSDefaultRunLoopMode切换为UITrackingRunLoopMode，而以+ scheduledTimerWithTimeInterval…的方式触发的timer，实质上是注册到NSDefaultRunLoopMode的，所以这时候timer会被暂停回调。要想不被暂停，可以将timer注册到NSRunLoopCommonModes下，因为NSDefaultRunLoopMode和UITrackingRunLoopMode都在NSRunLoopCommonModes mode集合中</p>
<h3 id="30-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"><a href="#30-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？" class="headerlink" title="30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"></a>30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3><p>同上一题</p>
<h3 id="31-猜想runloop内部是如何实现的？"><a href="#31-猜想runloop内部是如何实现的？" class="headerlink" title="31. 猜想runloop内部是如何实现的？"></a>31. 猜想runloop内部是如何实现的？</h3><p>do-while 循环</p>
<ol>
<li>通知Observer即将进入RunLoop</li>
<li>通知Observer即将处理Timer</li>
<li>通知Observer即将处理Source0</li>
<li>处理Source0</li>
<li>如果有Source1跳到9</li>
<li>通知Observer线程即将休眠</li>
<li>休眠等待被唤醒</li>
<li>通知Observer线程刚被唤醒</li>
<li>处理唤醒时受到的消息，跳回2</li>
<li>通知Observer即将退出RunLoop</li>
</ol>
<p>苹果在主线程注册了两个Observer：</p>
<ul>
<li>第一个Observer监听即将进入RunLoop事件：创建自动释放池AutoreleasePool</li>
<li>第二个Observer监听两个事件：<ul>
<li>即将进入休眠 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新的池；</li>
<li>退出RunLoop调用 _objc_autoreleasePoolPush() 释放自动释放池<h3 id="32-objc使用什么机制管理对象内存？"><a href="#32-objc使用什么机制管理对象内存？" class="headerlink" title="32.objc使用什么机制管理对象内存？"></a>32.objc使用什么机制管理对象内存？</h3>引用计数机制来管理对象内存</li>
</ul>
</li>
</ul>
<h3 id="33-ARC通过什么方式帮助开发者管理内存？"><a href="#33-ARC通过什么方式帮助开发者管理内存？" class="headerlink" title="33. ARC通过什么方式帮助开发者管理内存？"></a>33. ARC通过什么方式帮助开发者管理内存？</h3><p>编译期自动插入retain/release/autorelease 运行期</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/UIViewController、UINavigationController以及UITabBarController/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mochangxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mochangxing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/UIViewController、UINavigationController以及UITabBarController/" itemprop="url">
                  UIViewController、UINavigationController以及UITabBarController
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-01T13:32:01+08:00">2018-04-01</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="UIViewController"><a href="#UIViewController" class="headerlink" title="UIViewController"></a>UIViewController</h2><ul>
<li><p><code>UIViewController</code> 是管理<code>View</code>的一般管理器的基类，它提供了一些<code>View</code>出现或者消失时的回调方法，也就是生命周期。</p>
</li>
<li><p>子类可以通过重载 <code>loadView</code>方法来创建一个自定义的view层级结构</p>
</li>
</ul>
<h2 id="UINavigationController"><a href="#UINavigationController" class="headerlink" title="UINavigationController"></a>UINavigationController</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>UINavigationController</code> 用来管理<code>UIViewController</code>，在多<code>UIViewController</code>中常用。它以栈的形式管理<code>UIViewController</code>。</p>
<p>一般情况下，<code>UINavigationController</code>至少有一个视图控制器，即最少拥有一个根视图控制器。如果不给它添加根视图控制器，界面上也有视图，因为<code>UINavigationController</code>继承自<code>UIViewController</code>，不过此时<code>.view.backgroundColor</code>为<code>nil</code>，即透明</p>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul>
<li>push方法将某个视图控制器压入栈</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用setViewControllers一次压入多个控制器vc1-&gt;vc2-&gt;vc3，会显示最后的控制器vc3(处于栈顶)</li>
<li>使用pop方法可以移除栈顶控制器</li>
<li><code>popToRootViewControllerAnimated</code>回到根控制器</li>
<li>获取被管理的控制器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// 当前管理的所有的控制器</span><br><span class="line">@property(nonatomic,copy) NSArray&lt;__kindof UIViewController *&gt; *viewControllers;</span><br><span class="line"></span><br><span class="line">/// 栈顶控制器</span><br><span class="line">@property(nullable, nonatomic,readonly,strong) UIViewController *topViewController;</span><br><span class="line"></span><br><span class="line">/// 当前可见的VC，可能是topViewController，也可能是当前topViewController present(modal)出来的VC，总而言之就是可见的VC</span><br><span class="line">@property(nullable, nonatomic,readonly,strong) UIViewController *visibleViewController;</span><br></pre></td></tr></table></figure>
<h3 id="导航条"><a href="#导航条" class="headerlink" title="导航条"></a>导航条</h3><p><code>UINavigationController</code>是用来导航的，具体的大部分操作都有导航条来完成。导航条的内容有<code>UIViewController</code>的<code>navigationItem</code>属性决定</p>
<h3 id="UIToolBar-底部工具条"><a href="#UIToolBar-底部工具条" class="headerlink" title="UIToolBar 底部工具条"></a>UIToolBar 底部工具条</h3><p><code>UINavigationController</code>自带了一个工具栏，通过<code>[self.navigationController setToolbarHidden:NO];</code>来显示工具栏，工具栏中的内容可以通过<code>viewController</code>的<code>toolbarItems</code>来设置，显示的顺序和设置的<code>NSArray</code>中存放的顺序一致，每一个<code>UIBarButtonItem</code>对象都可以设定点击事件，可以使用系统提供的很多常用风格的对象，也可以根据需求进行自定义</p>
<h3 id="UINavigationBar、UINavigationItem、UIToolbar与UIBarButtonItem四者关系"><a href="#UINavigationBar、UINavigationItem、UIToolbar与UIBarButtonItem四者关系" class="headerlink" title="UINavigationBar、UINavigationItem、UIToolbar与UIBarButtonItem四者关系"></a>UINavigationBar、UINavigationItem、UIToolbar与UIBarButtonItem四者关系</h3><ul>
<li><code>NavigaitonBar</code>是导航栏，位于屏幕的上方，管理整个<code>NavigationController</code>的<code>navigationItem</code>，它类似<code>navigationcontroller</code>一样提供了一个栈来管理<code>UINavigationItem</code>，在编程时，一般只设置每个控制器的<code>navigationItem</code>属性</li>
<li>一个导航控制器管理多个视图控制器（多个视图控制器共享一个导航控制器），而一个导航控制器只有一个<code>UINavigationBar</code>，被管理的多个视图控制器共享这一个<code>UINavigationBar</code>，只要一个视图控制器改变了<code>UINavigationBar</code>的属性则影响是全局的。每个视图控制器都会有属于自己的<code>UINavigationItem</code>，系统会以懒加载的方式创建一个<code>UINavigationItem</code>显示在<code>UINavigationBar</code>中，改变<code>UINavigationItem</code>只会在当前控制器起作用，不会影响其它控制器。</li>
<li><code>Toolbar</code>显示在屏幕底部，是导航控制器的工具栏，一个导航控制器只有一个，在任何被管理的视图控制器地方改变则会都改变。可以一次性添加多个<code>UIBarButtonItem</code>或按钮（包装成UIBarButtonItem后添加），有一个items数组属性。</li>
<li><code>UIBarButtonItem</code>是<code>UINavigationItem</code>或者<code>Toolbar</code>具体的一个按钮。</li>
</ul>
<h2 id="UITabBarController-标签控制器"><a href="#UITabBarController-标签控制器" class="headerlink" title="UITabBarController 标签控制器"></a>UITabBarController 标签控制器</h2><p>标签控制器，管理一个选择展示界面，可以控制多个controller，无层级关系，标签栏中的每一个标签关联一个自定义的controller，选择标签切换显示相应的controller根视图</p>
<h3 id="UITabBar"><a href="#UITabBar" class="headerlink" title="UITabBar"></a>UITabBar</h3><p>标签栏，每个<code>UITabBarController</code>只有一个标签栏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface UITabBar : UIView</span><br><span class="line"></span><br><span class="line">@property(nullable, nonatomic, weak) id&lt;UITabBarDelegate&gt; delegate;     // weak reference. default is nil</span><br><span class="line"></span><br><span class="line">//UITabBarController中每个controller对应一个UITabBarItem</span><br><span class="line">@property(nullable, nonatomic, copy) NSArray&lt;UITabBarItem *&gt; *items;        // get/set visible UITabBarItems. default is nil. changes not animated. shown in order</span><br><span class="line">@property(nullable, nonatomic, weak) UITabBarItem *selectedItem; // will show feedback based on mode. default is nil</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="模态视图-modal"><a href="#模态视图-modal" class="headerlink" title="模态视图 modal"></a>模态视图 modal</h2><h3 id="模态视图的作用"><a href="#模态视图的作用" class="headerlink" title="模态视图的作用"></a>模态视图的作用</h3><ol>
<li>收集用户输入信息</li>
<li>临时呈现一些内容</li>
<li>临时改变工作模式</li>
<li>相应设备方向变化（用于针对不同方向分别是想两个ViewController的情况）</li>
<li>显示一个新的view层级</li>
</ol>
<p>这几种情形都会暂时中断程序正常的执行流程，主要作用是收集或者显示一些信息。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Mochangxing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mochangxing</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.1.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
